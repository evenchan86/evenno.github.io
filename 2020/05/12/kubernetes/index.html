<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/home/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/home/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/home/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/home/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/home/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/home/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/home/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="kubernetes," />




  


  <link rel="alternate" href="/home/atom.xml" title="DevOps" type="application/atom+xml" />






<meta name="description" content="python实例手册#encoding:utf8 设定编码-支持中文0 说明 手册制作: 雪松 littlepy www.51reboot.com 更新日期: 2020-03-06  欢迎系统运维加入Q群: 198173206  # 加群请回答问题 欢迎运维开发加入Q群: 365534424  # 不定期技术分享  请使用&quot;notepad++&quot;或其它编辑器打开此文档, &amp;quo">
<meta property="og:type" content="article">
<meta property="og:title" content="Python实例手册">
<meta property="og:url" content="https://evenno.github.io/2020/05/12/kubernetes/index.html">
<meta property="og:site_name" content="DevOps">
<meta property="og:description" content="python实例手册#encoding:utf8 设定编码-支持中文0 说明 手册制作: 雪松 littlepy www.51reboot.com 更新日期: 2020-03-06  欢迎系统运维加入Q群: 198173206  # 加群请回答问题 欢迎运维开发加入Q群: 365534424  # 不定期技术分享  请使用&quot;notepad++&quot;或其它编辑器打开此文档, &amp;quo">
<meta property="article:published_time" content="2020-05-12T04:24:00.000Z">
<meta property="article:modified_time" content="2020-05-12T06:07:15.989Z">
<meta property="article:author" content="Even Chan">
<meta property="article:tag" content="kubernetes">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/home/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://evenno.github.io/2020/05/12/kubernetes/"/>





  <title>Python实例手册 | DevOps</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/home/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DevOps</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/home/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/home/about/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/home/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/home/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/home/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/home/schedule/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/home/sitemap.xml%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/home/404/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://evenno.github.io/home/2020/05/12/kubernetes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Even Chan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/home/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DevOps">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Python实例手册</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-12T12:24:00+08:00">
                2020-05-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <pre><code>python实例手册</code></pre><p>#encoding:utf8</p>
<h1 id="设定编码-支持中文"><a href="#设定编码-支持中文" class="headerlink" title="设定编码-支持中文"></a>设定编码-支持中文</h1><p>0 说明</p>
<pre><code>手册制作: 雪松 littlepy www.51reboot.com
更新日期: 2020-03-06

欢迎系统运维加入Q群: 198173206  # 加群请回答问题
欢迎运维开发加入Q群: 365534424  # 不定期技术分享

请使用&quot;notepad++&quot;或其它编辑器打开此文档, &quot;alt+0&quot;将函数折叠后方便查阅
请勿删除信息, 转载请说明出处, 抵制不道德行为
错误在所难免, 还望指正！

[python实例手册] [shell实例手册] [LazyManage运维批量管理(shell/python两个版本)]
github更新下载地址:  https://github.com/liquanzhou/ops_doc</code></pre><p>1 基础</p>
<pre><code>安装python2.7

    wget https://www.python.org/ftp/python/2.7.9/Python-2.7.9.tgz

    tar xvf Python-2.7.9.tgz
    cd Python-2.7.9
    ./configure --prefix=/usr/local/python27
    make
    make install
    mv /usr/bin/python /usr/bin/python_old
    ln -s /usr/local/python27/bin/python /usr/bin/python
    python          # 查看版本

解决YUM无法使用的问题

   vim /usr/bin/yum
   vim /usr/bin/repoquery
   两文件首行#!/usr/bin/python 替换为老版本python  #!/usr/bin/python2.6  注意可能为2.4

pip模块安装

    yum install python-pip            # centos安装pip
    sudo apt-get install python-pip   # ubuntu安装pip
    pip官方安装脚本
        wget https://raw.github.com/pypa/pip/master/contrib/get-pip.py
        python get-pip.py
    pip编译安装
        # https://pypi.python.org/pypi/setuptools
        wget http://pypi.python.org/packages/source/s/setuptools/setuptools.tar.gz
        tar zxvf setuptools.tar.gz
        cd setuptools/
        python setup.py build
        python setup.py install
        # https://pypi.python.org/pypi/ez_setup
        tar zxvf ez_setup.tar.gz
        cd ez_setup/
        python setup.py build
        python setup.py install
        # https://pypi.python.org/pypi/pip
        tar zxvf pip.tar.gz
        cd pip/
        python setup.py build
        python setup.py install
    加载环境变量
        vim /etc/profile
        export PATH=/usr/local/python27/bin:$PATH
        . /etc/profile

    pip freeze                      # 查看包版本
    pip install -r file             # 安装包文件列表
    pip install Package             # 安装包 pip install requests
    pip show --files Package        # 查看安装包时安装了哪些文件
    pip show --files Package        # 查看哪些包有更新
    pip install --upgrade Package   # 更新一个软件包
    pip uninstall Package           # 卸载软件包
    pip list                        # 查看pip安装的包及版本
    pip install django==1.5         # 指定版本安装
    pip install  kafka-python -i http://pypi.douban.com/simple --trusted-host pypi.douban.com


python3安装
    yum install python36.x86_64 python36-pip

查看帮助

    python -c &quot;help(&apos;modules&apos;)&quot;     # 查看python所有模块
    import os
    for i in dir(os):
        print i         # 模块的方法
    help(os.path)       # 方法的帮助

python中关键字

    import keyword
    keyword.iskeyword(str)       # 字符串是否为python关键字
    keyword.kwlist               # 返回pytho所有关键字
    [&apos;and&apos;, &apos;as&apos;, &apos;assert&apos;, &apos;break&apos;, &apos;class&apos;, &apos;continue&apos;, &apos;def&apos;, &apos;del&apos;, &apos;elif&apos;, &apos;else&apos;, &apos;except&apos;, &apos;exec&apos;, &apos;finally&apos;, &apos;for&apos;, &apos;from&apos;, &apos;global&apos;, &apos;if&apos;, &apos;import&apos;, &apos;in&apos;, &apos;is&apos;, &apos;lambda&apos;, &apos;not&apos;, &apos;or&apos;, &apos;pass&apos;, &apos;print&apos;, &apos;raise&apos;, &apos;return&apos;, &apos;try&apos;, &apos;while&apos;, &apos;with&apos;, &apos;yield&apos;]

调试

    python -m trace -t aaaaaa.py
    strace -p pid       # 用系统命令跟踪系统调用

变量

    r=r&apos;\n&apos;          # 输出时原型打印
    u=u&apos;中文&apos;        # 定义为unicode编码
    global x         # 全局变量
    a = 0 or 2 or 1  # 布尔运算赋值,a值为True既不处理后面,a值为2.  None、字符串&apos;&apos;、空元组()、空列表[],空字典{}、0、空字符串都是false
    name = raw_input(&quot;input:&quot;).strip()        # 输入字符串变量
    num = int(raw_input(&quot;input:&quot;).strip())    # 输入字符串str转为int型
    locals()                                  # 所有局部变量组成的字典
    locals().values()                         # 所有局部变量值的列表
    os.popen(&quot;date -d @{0} +&apos;%Y-%m-%d %H:%M:%S&apos;&quot;.format(12)).read()    # 特殊情况引用变量 {0} 代表第一个参数

    基于字典的字符串格式化
        params = {&quot;server&quot;:&quot;mpilgrim&quot;, &quot;database&quot;:&quot;master&quot;, &quot;uid&quot;:&quot;sa&quot;, &quot;pwd&quot;:&quot;secret&quot;}
        &quot;%(pwd)s&quot; % params                                         # &apos;secret&apos;
        &quot;%(pwd)s is not a good password for %(uid)s&quot; % params      # &apos;secret is not a good password for sa&apos;
        &quot;%(database)s of mind, %(database)s of body&quot; % params      # &apos;master of mind, master of body&apos;

打印

    # 字符串 %s  整数 %d  浮点 %f  原样打印 %r
    print &apos;字符串: %s 整数: %d 浮点: %f 原样打印: %r&apos; % (&apos;aa&apos;,2,1.0,&apos;r&apos;)
    print &apos;abc&apos;,      # 有逗号,代表不换行打印,在次打印会接着本行打印
    print &apos;%-10s %s&apos; % (&apos;aaa&apos;,&apos;bbb&apos;)    # 左对齐 占10个字符
    print &apos;%10s %s&apos; % (&apos;aaa&apos;,&apos;bbb&apos;)     # 右对齐 占10个字符

列表

    # 列表元素的个数最多 536870912
    shoplist = [&apos;apple&apos;, &apos;mango&apos;, &apos;carrot&apos;, &apos;banana&apos;]
    shoplist[2] = &apos;aa&apos;
    del shoplist[0]
    shoplist.insert(4,&apos;www&apos;)
    shoplist.append(&apos;aaa&apos;)
    shoplist[::-1]    # 倒着打印 对字符翻转串有效
    shoplist[2::3]    # 从第二个开始每隔三个打印
    shoplist[:-1]     # 排除最后一个
    &apos;\t&apos;.join(li)     # 将列表转字符串 用字表符分割
    sys.path[1:1]=[5] # 在位置1前面插入列表中一个值
    list(set([&apos;qwe&apos;, &apos;as&apos;, &apos;123&apos;, &apos;123&apos;]))   # 将列表通过集合去重复
    eval(&quot;[&apos;1&apos;,&apos;a&apos;]&quot;)                        # 将字符串当表达式求值,得到列表

    # enumerate 可得到每个值的对应位置
    for i, n in enumerate([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]):
        print i,n

元组

    # 不可变
    zoo = (&apos;wolf&apos;, &apos;elephant&apos;, &apos;penguin&apos;)

字典

    ab = {       &apos;Swaroop&apos;   : &apos;swaroopch@byteofpython.info&apos;,
                 &apos;Larry&apos;     : &apos;larry@wall.org&apos;,
         }
    ab[&apos;c&apos;] = 80      # 添加字典元素
    del ab[&apos;Larry&apos;]   # 删除字典元素
    ab.keys()         # 查看所有键值
    ab.values()       # 打印所有值
    ab.has_key(&apos;a&apos;)   # 查看键值是否存在
    ab.items()        # 返回整个字典列表

    复制字典
        a = {1: {1: 2, 3: 4}}
        b = a
        b[1][1] = 8888                # a和b都为 {1: {1: 8888, 3: 4}}
        import copy
        c = copy.deepcopy(a)          # 再次赋值 b[1][1] = 9999 拷贝字典为新的字典,互不干扰

        a[2] = copy.deepcopy(a[1])    # 复制出第二个key，互不影响  {1: {1: 2, 3: 4},2: {1: 2, 3: 4}}

迭代器

    # 创建迭代接口，而不是原来的对象 支持字符串、列表和字典等序列对象
    i = iter(&apos;abcd&apos;)
    print i.next()

    s = {&apos;one&apos;:1,&apos;two&apos;:2,&apos;three&apos;:3}
    m = iter(s)
    print m.next()                     # 迭代key

流程结构

    if判断

        # 布尔值操作符 and or not 实现多重判断
        if a == b:
            print &apos;==&apos;
        elif a &lt; b:
            print b
        else:
            print a

    while循环

        while True:
            if a == b:
                print &quot;==&quot;
                break
            print &quot;!=&quot;
        else:
            print &apos;over&apos;

        count=0
        while(count&lt;9):
            print count
            count += 1

    for循环

        sorted()           # 返回一个序列(列表)
        zip()              # 返回一个序列(列表)
        enumerate()        # 返回循环列表序列 for i,v in enumerate([&apos;a&apos;,&apos;b&apos;]):
        reversed()         # 反序迭代器对象
        dict.iterkeys()    # 通过键迭代
        dict.itervalues()  # 通过值迭代
        dict.iteritems()   # 通过键-值对迭代
        readline()         # 文件迭代
        iter(obj)          # 得到obj迭代器 检查obj是不是一个序列
        iter(a,b)          # 重复调用a,直到迭代器的下一个值等于b
        for i in range(1, 5):
            print i
        else:
            print &apos;over&apos;

        list = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;b&apos;]
        for i in range(len(list)):
            print list[i]
        for x, Lee in enumerate(list):
            print &quot;%d %s Lee&quot; % (x+1,Lee)

        # enumerate 使用函数得到索引值和对应值
        for i, v in enumerate([&apos;tic&apos;, &apos;tac&apos;, &apos;toe&apos;]):
            print(i, v)

    流程结构简写

        [ i * 2 for i in [8,-2,5]]
        [16,-4,10]
        [ i for i in range(8) if i %2 == 0 ]
        [0,2,4,6]

tab补全

    # vim /usr/lib/python2.7/dist-packages/tab.py
    # python startup file
    import sys
    import readline
    import rlcompleter
    import atexit
    import os
    # tab completion
    readline.parse_and_bind(&apos;tab: complete&apos;)
    # history file
    histfile = os.path.join(os.environ[&apos;HOME&apos;], &apos;.pythonhistory&apos;)

函数

    def printMax(a, b = 1):
        if a &gt; b:
            print a
            return a
        else:
            print b
            return b
    x = 5
    y = 7
    printMax(x, y)

    def update(*args,**kwargs):
        p=&apos;&apos;
        for i,t in kwargs.items():
                p = p+ &apos;%s=%s,&apos; %(i,str(t))
        sql = &quot;update  &apos;user&apos; set (%s) where (%s)&quot; %(args[0],p)
        print sql

    update(&apos;aaa&apos;,uu=&apos;uu&apos;,id=3)

模块

    # Filename: mymodule.py
    def sayhi():
        print &apos;mymodule&apos;
    version = &apos;0.1&apos;

    # 使用模块中方法
    import mymodule
    from mymodule import sayhi, version
    mymodule.sayhi()   # 使用模块中函数方法

装饰器

    # 为已存在的功能添加额外的功能,只在初始化脚本的时候执行一次

    #!/usr/bin/env python

    def deco(func):
        def wrapper(*args, **kwargs):
            print &quot;Wrap start&quot;
            func(*args, **kwargs)
            func(*args, **kwargs)
            print &quot;Wrap end\n&quot;
        return wrapper

    @deco
    def foo(x):
        print &quot;In foo():&quot;
        print &quot;I have a para: %s&quot; % x
    @deco
    def foo_dict(x,z=&apos;dict_para&apos;):
        print &quot;In foo_dict:&quot;
        print &quot;I have two para, %s and %s&quot; % (x, z)

    if __name__ == &quot;__main__&quot;:
        # 装饰器 @deco  等价于 foo = deco(foo)
        foo(&apos;x&apos;)
        foo_dict(&apos;x&apos;, z=&apos;dict_para&apos;)

    结果

        Wrap start
        In foo():
        I have a para: x
        In foo():
        I have a para: x
        Wrap end

        Wrap start
        In foo_dict:
        I have two para, x and dict_para
        In foo_dict:
        I have two para, x and dict_para
        Wrap end

类对象的方法

    __xxx__               # 系统定义名字
    __init__              # 实例化初始化类的方法
    __all__ = [&apos;xs&apos;]      # __all__ 用于模块import导入时限制,定义了只有all内指定的属性、方法、类可被导入,没定义则模块内的所有将被导入
    _xxx                  # _开头的为私有类,只有类对象和子类对象自己能访问到这些变量  不能用 from module import * 导入  class _status:
    __xxx                 # __开头的为类中的私有变量名,只有类对象自己能访问,连子类对象也不能访问到这个数据

    class Person:
        # 实例化初始化的方法
        def __init__(self, name ,age):
            self.name = name
            self.age = age
            print self.name
        # 有self此函数为方法
        def sayHi(self):
            print &apos;Hello, my name is&apos;, self.name
        # 对象消逝的时候被调用
        def __del__(self):
            print &apos;over&apos;
    # 实例化对象
    p = Person(&apos;Swaroop&apos;,23)
    # 使用对象方法
    p.sayHi()
    # 继承
    class Teacher(Person):
        def __init__(self, name, age, salary):
            Person.__init__(self, name, age)
            self.salary = salary
            print &apos;(Initialized Teacher: %s)&apos; % self.name
        def tell(self):
            Person.tell(self)
            print &apos;Salary: &quot;%d&quot;&apos; % self.salary
    t = Teacher(&apos;Mrs. Shrividya&apos;, 40, 30000)

    getattr(object,name,default)

        # 返回object的名称为name的属性的属性值,如果属性name存在,则直接返回其属性值.如果属性name不存在,则触发AttribetError异常或当可选参数default定义时返回default值

        class A:
            def __init__(self):
                self.name = &apos;zhangjing&apos;
            def method(self):
                print&quot;method print&quot;

        Instance = A()
        print getattr(Instance, &apos;name&apos;,   &apos;not find&apos;)          # 如果Instance 对象中有属性name则打印self.name的值，否则打印&apos;not find&apos;
        print getattr(Instance, &apos;age&apos;,    &apos;not find&apos;)          # 如果Instance 对象中有属性age则打印self.age的值，否则打印&apos;not find&apos;
        print getattr(Instance, &apos;method&apos;, &apos;default&apos;)           # 如果有方法method，否则打印其地址，否则打印default
        print getattr(Instance, &apos;method&apos;, &apos;default&apos;)()         # 如果有方法method，运行函数并打印None否则打印default

    setattr(object,name,value)

        # 设置object的名称为name(type：string)的属性的属性值为value，属性name可以是已存在属性也可以是新属性。

        #等同多次 self.name = name 赋值 在外部可以直接把变量和值对应关系传进去
        #class Person:
        #    def __init__(self, name ,age):
        #        self.name = name
        #        self.age = age

        config = {&apos;name&apos;:&apos;name&apos;,&apos;age&apos;,&apos;age&apos;}
        class Configure(object):
            def __init__(self, config):
                self.register(config)

            def register(self, config):
                for key, value in config.items():
                    if key.upper() == key:
                        setattr(self, key, value)

模块包

    # 文件 ops/fileserver/__init__.py
    import readers
    import writers

    # 每个模块的包中，都有一个 __init__.py 文件，有了这个文件，才能导入这个目录下的module，在导入一个包时 import ops.fileserver ，实际上是导入了它的 __init__.py 文件，可以再 __init__.py 文件中再导入其他的包，或者模块。就不需要将所有的import语句写在一个文件里了，也可以减少代码量，不需要一个个去导入module了。
    # __init__.py 有一个重要的变量 __all__ 。有时会需要全部导入，from PackageName import *   ，这时 import 就会把注册在包 __init__.py 文件中 __all__ 列表中的子模块和子包导入到当前作用域中来。如：
    __all__ = [&quot;Module1&quot;, &quot;Module2&quot;, &quot;subPackage1&quot;, &quot;subPackage2&quot;]

执行模块类中的所有方法

    # moniItems.py
    import sys, time
    import inspect

    class mon:
        def __init__(self):
            self.data = dict()
        def run(self):
            return self.runAllGet()
        def getDisk(self):
            return 222
        def getCpu(self):
            return 111
        def runAllGet(self):
            for fun in inspect.getmembers(self, predicate=inspect.ismethod):
                print fun[0], fun[1]
                if fun[0][:3] == &apos;get&apos;:
                    self.data[fun[0][3:]] = fun[1]()
            print self.data
            return self.data

    # 模块导入使用
    from moniItems import mon
    m = mon()
    m.runAllGet()

文件处理

    # 模式: 读&apos;r&apos;  写[清空整个文件]&apos;w&apos; 追加[文件需要存在]&apos;a&apos; 读写&apos;r+&apos; 二进制文件&apos;b&apos;  &apos;rb&apos;,&apos;wb&apos;,&apos;rb+&apos;

    写文件
        i={&apos;ddd&apos;:&apos;ccc&apos;}
        f = file(&apos;poem.txt&apos;, &apos;a&apos;)
        f.write(&quot;string&quot;)
        f.write(str(i))
        f.flush()
        f.close()

    读文件
        f = file(&apos;/etc/passwd&apos;,&apos;r&apos;)
        c = f.read().strip()        # 读取为一个大字符串，并去掉最后一个换行符
        for i in c.split(&apos;\n&apos;):     # 用换行符切割字符串得到列表循环每行
            print i
        f.close()

    读文件1
        f = file(&apos;/etc/passwd&apos;,&apos;r&apos;)
        while True:
            line = f.readline()    # 返回一行
            if len(line) == 0:
                break
            x = line.split(&quot;:&quot;)                  # 冒号分割定义序列
            #x = [ x for x in line.split(&quot;:&quot;) ]  # 冒号分割定义序列
            #x = [ x.split(&quot;/&quot;) for x in line.split(&quot;:&quot;) ]  # 先冒号分割,在/分割 打印x[6][1]
            print x[6],&quot;\n&quot;,
        f.close()

    读文件2
        f = file(&apos;/etc/passwd&apos;)
        c = f.readlines()       # 读入所有文件内容,可反复读取,大文件时占用内存较大
        for line in c:
            print line.rstrip(),
        f.close()

    读文件3
        for i in open(&apos;b.txt&apos;):   # 直接读取也可迭代,并有利于大文件读取,但不可反复读取
            print i,

    追加日志
        log = open(&apos;/home/peterli/xuesong&apos;,&apos;a&apos;)
        print &gt;&gt; log,&apos;faaa&apos;
        log.close()

    with读文件

        # 自动关闭文件、线程锁的自动获取和释放等
        with open(&apos;a.txt&apos;) as f:
            for i in f:
                print i
            print f.read()        # 打印所有内容为字符串
            print f.readlines()   # 打印所有内容按行分割的列表

    文件随机读写

        # 文件本没有换行,一切都是字符,文件也没有插入功能
        f.tell()       # 当前读写位置
        f.read(5)      # 读取5个字符并改变指针
        f.seek(5)      # 改变用户态读写指针偏移位置,可做随机写
        f.seek(p,0)    # 移动当文件第p个字节处，绝对位置
        f.seek(p,1)    # 移动到相对于当前位置之后的p个字节
        f.seek(p,2)    # 移动到相对文件尾之后的p个字节
        f.seek(0,2)    # 指针指到尾部
        # 改变指针超出文件尾部,会造成文件洞,ll看占用较大，但du -sh却非常小
        f.read(65535)  # 读取64K字节
        f.write(&quot;str&quot;) # 写会覆盖当前指针后的响应字符,无插入功能

内建函数

    dir(sys)            # 显示对象的属性
    help(sys)           # 交互式帮助
    int(obj)            # 转型为整形
    str(obj)            # 转为字符串
    len(obj)            # 返回对象或序列长度
    open(file,mode)     # 打开文件 #mode (r 读,w 写, a追加)
    range(0,3)          # 返回一个整形列表
    raw_input(&quot;str:&quot;)   # 等待用户输入
    type(obj)           # 返回对象类型
    abs(-22)            # 绝对值
    random              # 随机数
    choice()            # 随机返回给定序列的一个元素
    divmod(x,y)         # 函数完成除法运算，返回商和余数。
    round(x[,n])        # 函数返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数
    strip()             # 是去掉字符串两端多于空格,该句是去除序列中的所有字串两端多余的空格
    del                 # 删除列表里面的数据
    cmp(x,y)            # 比较两个对象    #根据比较结果返回一个整数，如果x&lt;y，则返回-1；如果x&gt;y，则返回1,如果x==y则返回0
    max()               # 字符串中最大的字符
    min()               # 字符串中最小的字符
    sorted()            # 对序列排序
    reversed()          # 对序列倒序
    enumerate()         # 返回索引位置和对应的值
    sum()               # 总和
    list()              # 变成列表可用于迭代
    eval(&apos;3+4&apos;)         # 将字符串当表达式求值 得到7
    exec &apos;a=100&apos;        # 将字符串按python语句执行
    exec(a+&apos;=new&apos;)      # 将变量a的值作为新的变量
    tuple()             # 变成元组可用于迭代   #一旦初始化便不能更改的数据结构,速度比list快
    zip(s,t)            # 返回一个合并后的列表  s = [&apos;11&apos;,&apos;22&apos;]  t = [&apos;aa&apos;,&apos;bb&apos;]  [(&apos;11&apos;, &apos;aa&apos;), (&apos;22&apos;, &apos;bb&apos;)]
    isinstance(object,int)    # 测试对象类型 int
    xrange([lower,]stop[,step])            # 函数与range()类似，但xrnage()并不创建列表，而是返回一个xrange对象

列表类型内建函数

    list.append(obj)                 # 向列表中添加一个对象obj
    list.count(obj)                  # 返回一个对象obj在列表中出现的次数
    list.extend(seq)                 # 把序列seq的内容添加到列表中
    list.index(obj,i=0,j=len(list))  # 返回list[k] == obj 的k值,并且k的范围在i&lt;=k&lt;j;否则异常
    list.insert(index.obj)           # 在索引量为index的位置插入对象obj
    list.pop(index=-1)               # 删除并返回指定位置的对象,默认是最后一个对象
    list.remove(obj)                 # 从列表中删除对象obj
    list.reverse()                   # 原地翻转列表
    list.sort(func=None,key=None,reverse=False)  # 以指定的方式排序列表中成员,如果func和key参数指定,则按照指定的方式比较各个元素,如果reverse标志被置为True,则列表以反序排列

序列类型操作符

    seq[ind]              # 获取下标为ind的元素
    seq[ind1:ind2]        # 获得下标从ind1到ind2的元素集合
    seq * expr            # 序列重复expr次
    seq1 + seq2           # 连接seq1和seq2
    obj in seq            # 判断obj元素是否包含在seq中
    obj not in seq        # 判断obj元素是否不包含在seq中

字符串类型内建方法

    string.expandtabs(tabsize=8)                  # tab符号转为空格 #默认8个空格
    string.endswith(obj,beg=0,end=len(staring))   # 检测字符串是否已obj结束,如果是返回True #如果beg或end指定检测范围是否已obj结束
    string.count(str,beg=0,end=len(string))       # 检测str在string里出现次数  f.count(&apos;\n&apos;,0,len(f)) 判断文件行数
    string.find(str,beg=0,end=len(string))        # 检测str是否包含在string中
    string.index(str,beg=0,end=len(string))       # 检测str不在string中,会报异常
    string.isalnum()                              # 如果string至少有一个字符并且所有字符都是字母或数字则返回True
    string.isalpha()                              # 如果string至少有一个字符并且所有字符都是字母则返回True
    string.isnumeric()                            # 如果string只包含数字字符,则返回True
    string.isspace()                              # 如果string包含空格则返回True
    string.isupper()                              # 字符串都是大写返回True
    string.islower()                              # 字符串都是小写返回True
    string.lower()                                # 转换字符串中所有大写为小写
    string.upper()                                # 转换字符串中所有小写为大写
    string.lstrip()                               # 去掉string左边的空格
    string.rstrip()                               # 去掉string字符末尾的空格
    string.replace(str1,str2)                     # 把string中的str1替换成str2,如果num指定,则替换不超过num次
    string.startswith(obj,beg=0,end=len(string))  # 检测字符串是否以obj开头
    string.zfill(width)                           # 返回字符长度为width的字符,原字符串右对齐,前面填充0
    string.isdigit()                              # 只包含数字返回True
    string.split(&quot;/&quot;)                             # 把string切片成一个列表
    &quot;:&quot;.join(string.split())                      # 以:作为分隔符,将所有元素合并为一个新的字符串

字典内建方法

    dict.clear()                            # 删除字典中所有元素
    dict copy()                             # 返回字典(浅复制)的一个副本
    dict.fromkeys(seq,val=None)             # 创建并返回一个新字典,以seq中的元素做该字典的键,val做该字典中所有键对的初始值
    dict.get(key,default=None)              # 对字典dict中的键key,返回它对应的值value,如果字典中不存在此键,则返回default值
    dict.has_key(key)                       # 如果键在字典中存在,则返回True 用in和not in代替
    dict.items()                            # 返回一个包含字典中键、值对元组的列表
    dict.keys()                             # 返回一个包含字典中键的列表
    dict.iter()                             # 方法iteritems()、iterkeys()、itervalues()与它们对应的非迭代方法一样,不同的是它们返回一个迭代子,而不是一个列表
    dict.pop(key[,default])                 # 和方法get()相似.如果字典中key键存在,删除并返回dict[key]
    dict.setdefault(key,default=None)       # 和set()相似,但如果字典中不存在key键,由dict[key]=default为它赋值
    dict.update(dict2)                      # 将字典dict2的键值对添加到字典dict
    dict.values()                           # 返回一个包含字典中所有值得列表

    dict([container])     # 创建字典的工厂函数。提供容器类(container),就用其中的条目填充字典
    len(mapping)          # 返回映射的长度(键-值对的个数)
    hash(obj)             # 返回obj哈希值,判断某个对象是否可做一个字典的键值

集合方法

    s.update(t)                         # 用t中的元素修改s,s现在包含s或t的成员   s |= t
    s.intersection_update(t)            # s中的成员是共用属于s和t的元素          s &amp;= t
    s.difference_update(t)              # s中的成员是属于s但不包含在t中的元素    s -= t
    s.symmetric_difference_update(t)    # s中的成员更新为那些包含在s或t中,但不是s和t共有的元素  s ^= t
    s.add(obj)                          # 在集合s中添加对象obj
    s.remove(obj)                       # 从集合s中删除对象obj;如果obj不是集合s中的元素(obj not in s),将引发KeyError错误
    s.discard(obj)                      # 如果obj是集合s中的元素,从集合s中删除对象obj
    s.pop()                             # 删除集合s中的任意一个对象,并返回它
    s.clear()                           # 删除集合s中的所有元素
    s.issubset(t)                       # 如果s是t的子集,则返回True   s &lt;= t
    s.issuperset(t)                     # 如果t是s的超集,则返回True   s &gt;= t
    s.union(t)                          # 合并操作;返回一个新集合,该集合是s和t的并集   s | t
    s.intersection(t)                   # 交集操作;返回一个新集合,该集合是s和t的交集   s &amp; t
    s.difference(t)                     # 返回一个新集合,改集合是s的成员,但不是t的成员  s - t
    s.symmetric_difference(t)           # 返回一个新集合,该集合是s或t的成员,但不是s和t共有的成员   s ^ t
    s.copy()                            # 返回一个新集合,它是集合s的浅复制
    obj in s                            # 成员测试;obj是s中的元素 返回True
    obj not in s                        # 非成员测试:obj不是s中元素 返回True
    s == t                              # 等价测试 是否具有相同元素
    s != t                              # 不等价测试
    s &lt; t                               # 子集测试;s!=t且s中所有元素都是t的成员
    s &gt; t                               # 超集测试;s!=t且t中所有元素都是s的成员

序列化

    #!/usr/bin/python
    import cPickle
    obj = {&apos;1&apos;:[&apos;4124&apos;,&apos;1241&apos;,&apos;124&apos;],&apos;2&apos;:[&apos;12412&apos;,&apos;142&apos;,&apos;1241&apos;]}

    pkl_file = open(&apos;account.pkl&apos;,&apos;wb&apos;)
    cPickle.dump(obj,pkl_file)
    pkl_file.close()

    pkl_file = open(&apos;account.pkl&apos;,&apos;rb&apos;)
    account_list = cPickle.load(pkl_file)
    pkl_file.close()

文件对象方法

    file.close()                     # 关闭文件
    file.fileno()                    # 返回文件的描述符
    file.flush()                     # 刷新文件的内部缓冲区
    file.isatty()                    # 判断file是否是一个类tty设备
    file.next()                      # 返回文件的下一行,或在没有其他行时引发StopIteration异常
    file.read(size=-1)               # 从文件读取size个字节,当未给定size或给定负值的时候,读取剩余的所有字节,然后作为字符串返回
    file.readline(size=-1)           # 从文件中读取并返回一行(包括行结束符),或返回最大size个字符
    file.readlines(sizhint=0)        # 读取文件的所有行作为一个列表返回
    file.xreadlines()                # 用于迭代,可替换readlines()的一个更高效的方法
    file.seek(off, whence=0)         # 在文件中移动文件指针,从whence(0代表文件起始,1代表当前位置,2代表文件末尾)偏移off字节
    file.tell()                      # 返回当前在文件中的位置
    file.truncate(size=file.tell())  # 截取文件到最大size字节,默认为当前文件位置
    file.write(str)                  # 向文件写入字符串
    file.writelines(seq)             # 向文件写入字符串序列seq;seq应该是一个返回字符串的可迭代对象

文件对象的属性

    file.closed          # 表示文件已被关闭,否则为False
    file.encoding        # 文件所使用的编码  当unicode字符串被写入数据时,它将自动使用file.encoding转换为字节字符串;若file.encoding为None时使用系统默认编码
    file.mode            # Access文件打开时使用的访问模式
    file.name            # 文件名
    file.newlines        # 未读取到行分隔符时为None,只有一种行分隔符时为一个字符串,当文件有多种类型的行结束符时,则为一个包含所有当前所遇到的行结束符的列表
    file.softspace       # 为0表示在输出一数据后,要加上一个空格符,1表示不加

异常处理

    # try 中使用 sys.exit(2) 会被捕获,无法退出脚本,可使用 os._exit(2) 退出脚本

    class ShortInputException(Exception):  # 继承Exception异常的类,定义自己的异常
        def __init__(self, length, atleast):
            Exception.__init__(self)
            self.length = length
            self.atleast = atleast
    try:
        s = raw_input(&apos;Enter something --&gt; &apos;)
        if len(s) &lt; 3:
            raise ShortInputException(len(s), 3)    # 触发异常
    except EOFError:
        print &apos;\nWhy did you do an EOF on me?&apos;
    except ShortInputException, x:      # 捕捉指定错误信息
        print &apos;ShortInputException:  %d | %d&apos; % (x.length, x.atleast)
    except Exception as err:            # 捕捉所有其它错误信息内容
        print str(err)
    #except urllib2.HTTPError as err:   # 捕捉外部导入模块的错误
    #except:                            # 捕捉所有其它错误 不会看到错误内容
    #        print &apos;except&apos;
    finally:                            # 无论什么情况都会执行 关闭文件或断开连接等
           print &apos;finally&apos;
    else:                               # 无任何异常 无法和finally同用
        print &apos;No exception was raised.&apos;

    不可捕获的异常

        NameError:              # 尝试访问一个未申明的变量
        ZeroDivisionError:      # 除数为零
        SyntaxErrot:            # 解释器语法错误
        IndexError:             # 请求的索引元素超出序列范围
        KeyError:               # 请求一个不存在的字典关键字
        IOError:                # 输入/输出错误
        AttributeError:         # 尝试访问未知的对象属性
        ImportError             # 没有模块
        IndentationError        # 语法缩进错误
        KeyboardInterrupt       # ctrl+C
        SyntaxError             # 代码语法错误
        ValueError              # 值错误
        TypeError               # 传入对象类型与要求不符合

    内建异常

        BaseException                # 所有异常的基类
        SystemExit                   # python解释器请求退出
        KeyboardInterrupt            # 用户中断执行
        Exception                    # 常规错误的基类
        StopIteration                # 迭代器没有更多的值
        GeneratorExit                # 生成器发生异常来通知退出
        StandardError                # 所有的内建标准异常的基类
        ArithmeticError              # 所有数值计算错误的基类
        FloatingPointError           # 浮点计算错误
        OverflowError                # 数值运算超出最大限制
        AssertionError               # 断言语句失败
        AttributeError               # 对象没有这个属性
        EOFError                     # 没有内建输入,到达EOF标记
        EnvironmentError             # 操作系统错误的基类
        IOError                      # 输入/输出操作失败
        OSError                      # 操作系统错误
        WindowsError                 # windows系统调用失败
        ImportError                  # 导入模块/对象失败
        KeyboardInterrupt            # 用户中断执行(通常是ctrl+c)
        LookupError                  # 无效数据查询的基类
        IndexError                   # 序列中没有此索引(index)
        KeyError                     # 映射中没有这个键
        MemoryError                  # 内存溢出错误(对于python解释器不是致命的)
        NameError                    # 未声明/初始化对象(没有属性)
        UnboundLocalError            # 访问未初始化的本地变量
        ReferenceError               # 若引用试图访问已经垃圾回收了的对象
        RuntimeError                 # 一般的运行时错误
        NotImplementedError          # 尚未实现的方法
        SyntaxError                  # python语法错误
        IndentationError             # 缩进错误
        TabError                     # tab和空格混用
        SystemError                  # 一般的解释器系统错误
        TypeError                    # 对类型无效的操作
        ValueError                   # 传入无效的参数
        UnicodeError                 # Unicode相关的错误
        UnicodeDecodeError           # Unicode解码时的错误
        UnicodeEncodeError           # Unicode编码时的错误
        UnicodeTranslateError        # Unicode转换时错误
        Warning                      # 警告的基类
        DeprecationWarning           # 关于被弃用的特征的警告
        FutureWarning                # 关于构造将来语义会有改变的警告
        OverflowWarning              # 旧的关于自动提升为长整形的警告
        PendingDeprecationWarning    # 关于特性将会被废弃的警告
        RuntimeWarning               # 可疑的运行时行为的警告
        SyntaxWarning                # 可疑的语法的警告
        UserWarning                  # 用户代码生成的警告

    触发异常

        raise exclass            # 触发异常,从exclass生成一个实例(不含任何异常参数)
        raise exclass()          # 触发异常,但现在不是类;通过函数调用操作符(function calloperator:&quot;()&quot;)作用于类名生成一个新的exclass实例,同样也没有异常参数
        raise exclass, args      # 触发异常,但同时提供的异常参数args,可以是一个参数也可以是元组
        raise exclass(args)      # 触发异常,同上
        raise exclass, args, tb  # 触发异常,但提供一个跟踪记录(traceback)对象tb供使用
        raise exclass,instance   # 通过实例触发异常(通常是exclass的实例)
        raise instance           # 通过实例触发异常;异常类型是实例的类型:等价于raise instance.__class__, instance
        raise string             # 触发字符串异常
        raise string, srgs       # 触发字符串异常,但触发伴随着args
        raise string,args,tb     # 触发字符串异常,但提供一个跟踪记录(traceback)对象tb供使用
        raise                    # 重新触发前一个异常,如果之前没有异常,触发TypeError

    跟踪异常栈

        # traceback 获取异常相关数据都是通过sys.exc_info()函数得到的
        import traceback
        import sys
        try:
            s = raw_input()
            print int(s)
        except ValueError:
            # sys.exc_info() 返回值是元组，第一个exc_type是异常的对象类型，exc_value是异常的值，exc_tb是一个traceback对象，对象中包含出错的行数、位置等数据
            exc_type, exc_value, exc_tb = sys.exc_info()
            print &quot;\n%s \n %s \n %s\n&quot; %(exc_type, exc_value, exc_tb )
            traceback.print_exc()        # 打印栈跟踪信息

    抓取全部错误信息存如字典

        import sys, traceback

        try:
            s = raw_input()
            int(s)
        except:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            traceback_details = {
                                 &apos;filename&apos;: exc_traceback.tb_frame.f_code.co_filename,
                                 &apos;lineno&apos;  : exc_traceback.tb_lineno,
                                 &apos;name&apos;    : exc_traceback.tb_frame.f_code.co_name,
                                 &apos;type&apos;    : exc_type.__name__,
                                 &apos;message&apos; : exc_value.message,
                                }

            del(exc_type, exc_value, exc_traceback)
            print traceback_details
            f = file(&apos;test1.txt&apos;, &apos;a&apos;)
            f.write(&quot;%s %s %s %s %s\n&quot; %(traceback_details[&apos;filename&apos;],traceback_details[&apos;lineno&apos;],traceback_details[&apos;name&apos;],traceback_details[&apos;type&apos;],traceback_details[&apos;message&apos;], ))
            f.flush()
            f.close()

调试log

    # cgitb覆盖了默认sys.excepthook全局异常拦截器
    def func(a, b):
        return a / b
    if __name__ == &apos;__main__&apos;:
        import cgitb
        cgitb.enable(format=&apos;text&apos;)
        func(1, 0)

函数式编程的内建函数

    apply(func[,nkw][,kw])          # 用可选的参数来调用func,nkw为非关键字参数,kw为关键字参数;返回值是函数调用的返回值
    filter(func,seq)                # 调用一个布尔函数func来迭代遍历每个seq中的元素;返回一个使func返回值为true的元素的序列
    map(func,seq1[,seq2])           # 将函数func作用于给定序列(s)的每个元素,并用一个列表来提供返回值;如果func为None,func表现为一个身份函数,返回一个含有每个序列中元素集合的n个元组的列表
    reduce(func,seq[,init])         # 将二元函数作用于seq序列的元素,每次携带一堆(先前的结果以及下一个序列元素),连续地将现有的结果和下一个值作用在获得的随后的结果上,最后减少我们的序列为一个单一的返回值;如果初始值init给定,第一个比较会是init和第一个序列元素而不是序列的头两个元素
    lambda x,y:x+y                  # 创建一个匿名函数 可用于上面几种方法中直接创建匿名函数式

    # filter 即通过函数方法只保留结果为真的值组成列表
    def f(x): return x % 2 != 0 and x % 3 != 0
    f(3)     # 函数结果是False  3被filter抛弃
    f(5)     # 函数结果是True   5被加入filter最后的列表结果
    filter(f, range(2, 25))
    [5, 7, 11, 13, 17, 19, 23]

    # map 通过函数对列表进行处理得到新的列表
    def cube(x): return x*x*x
    map(cube, range(1, 11))
    [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]

    # reduce 通过函数会先接收初始值和序列的第一个元素，然后是返回值和下一个元素，依此类推
    def add(x,y): return x+y
    reduce(add, range(1, 11))              # 结果55  是1到10的和  x的值是上一次函数返回的结果，y是列表中循环的值
    reduce(lambda x,y:x+y, range(1,11))    # 等同上面两条  lambda来创建匿名函数[ lambda x,y:x+y ] ,后面跟可迭代的对象

编码转换

    a=&apos;中文&apos;                    # 编码未定义按输入终端utf8或gbk
    u=u&apos;中文&apos;                   # 定义为unicode编码  u值为 u&apos;\u4e2d\u6587&apos;
    u.encode(&apos;utf8&apos;)            # 转为utf8格式 u值为 &apos;\xe4\xb8\xad\xe6\x96\x87&apos;
    print u                     # 结果显示 中文
    print u.encode(&apos;utf8&apos;)      # 转为utf8格式,当显示终端编码为utf8  结果显示 中文  编码不一致则乱码
    print u.encode(&apos;gbk&apos;)       # 当前终端为utf8 故乱码
    ord(&apos;4&apos;)                    # 字符转ASCII码
    chr(52)                     # ASCII码转字符

    设置读取编码为utf8 避免转换出错

        #!/usr/bin/env python
        # -*- coding: utf-8 -*-

        import sys
        reload(sys)
        sys.setdefaultencoding(&apos;utf-8&apos;)

遍历递归

    [os.path.join(x[0],y) for x in os.walk(&apos;/root/python/5&apos;) for y in x[2]]

    for i in os.walk(&apos;/root/python/5/work/server&apos;):
        print i

元类

    # 实现动态curd类的或者实例中的方法属性

    #!/usr/bin/env python
    # -*- coding:utf-8 -*-
    # Name:        metaclass.py
    # Author:      ZhiPeng Wang.
    # Created:     15/8/12
    # Copyright:   (c) TigerJoys-SA 2015
    # -----------------------------------------------------------------------------

    &quot;&quot;&quot;首先检查__metaclass__属性, 如果设置了此属性, 如果设置了此属性则调用对应Metaclass,
    Metaclass本身也是Class 当调用时先调用自身的__new__方法新建一个Instance然后Instance调
    用__init__返回一个新对象(MyClss), 然后正常执行原Class
    &quot;&quot;&quot;

    ext_attr = {
        &apos;wzp&apos;: &apos;wzp&apos;,
        &apos;test&apos;: &apos;test&apos;,
    }

    class CustomMeta(type):
        build_in_attr = [&apos;name&apos;, ]

        def __new__(cls, class_name, bases, attributes):
            # 获取`Meta` Instance
            attr_meta = attributes.pop(&apos;Meta&apos;, None)
            if attr_meta:
                for attr in cls.build_in_attr:      # 遍历内置属性
                    # 自省, 获取Meta Attributes 不是build_in_attr的属性不处理
                    print &quot;Meta:&quot;, getattr(attr_meta, attr, False)
            # 扩展属性
            attributes.update(ext_attr)
            return type.__new__(cls, class_name, bases, attributes)

        def __init__(cls, class_name, bases, attributes):
            super(CustomMeta, cls).__init__(class_name, bases, attributes)

    class MyClass(object):
        __metaclass__ = CustomMeta  # metaclass
        class Meta:
            name = &apos;Meta attr&apos;

    if __name__ == &apos;__main__&apos;:

        # TODO 此处返回一个类｀Instance｀对象
        print MyClass()

        # TODO 此处返回一个类对象, 并不是｀Instance｀
        print type(&quot;MyClass&quot;, (), {})</code></pre><p>2 常用模块</p>
<pre><code>sys             [系统操作模块]

    sys.argv              # 取参数列表
    sys.exit(2)           # 退出脚本返回状态 会被try截取
    sys.exc_info()        # 获取当前正在处理的异常类
    sys.version           # 获取Python解释程序的版本信息
    sys.maxint            # 最大的Int值  9223372036854775807
    sys.maxunicode        # 最大的Unicode值
    sys.modules           # 返回系统导入的模块字段，key是模块名，value是模块
    sys.path              # 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值
    sys.platform          # 返回操作系统平台名称
    sys.stdout            # 标准输出
    sys.stdin             # 标准输入
    sys.stderr            # 错误输出
    sys.exec_prefix       # 返回平台独立的python文件安装的位置
    sys.stdin.readline()  # 从标准输入读一行
    sys.stdout.write(&quot;a&quot;) # 屏幕输出a
    sys.path.insert(1, os.path.join(sys.path[0], &apos;/opt/script/&apos;))     # 将/opt/script/目录加入环境变量，可导入相应模块
commands        [执行系统操作]

    (status, output) = commands.getstatusoutput(&apos;cat /proc/cpuinfo&apos;)
    print status, output

os              [系统模块]

    # 相对sys模块 os模块更为底层 os._exit() try无法抓取
    os.popen(&apos;id&apos;).read()      # 执行系统命令得到返回结果
    os.system()                # 得到返回状态 返回无法截取
    os.name                    # 返回系统平台 Linux/Unix用户是&apos;posix&apos;
    os.getenv()                # 读取环境变量
    os.environ[&apos;A&apos;]=&apos;1&apos;        # 设置环境变量
    os.getcwd()                # 当前工作路径
    os.chdir()                 # 改变当前工作目录
    os.walk(&apos;/root/&apos;)          # 递归路径
    os.environ[&apos;HOME&apos;]         # 查看系统环境变量
    os.statvfs(&quot;/&quot;)            # 获取磁盘信息

    文件处理
        mkfifo()/mknod()       # 创建命名管道/创建文件系统节点
        remove()/unlink()      # 删除文件
        rename()/renames()     # 重命名文件
        stat()                 # 返回文件信息
        symlink()              # 创建符号链接
        utime()                # 更新时间戳
        tmpfile()              # 创建并打开(&apos;w+b&apos;)一个新的临时文件
        walk()                 # 遍历目录树下的所有文件名

        oct(os.stat(&apos;th1.py&apos;).st_mode)[-3:]      # 查看目录权限

    目录/文件夹
        chdir()/fchdir()       # 改变当前工作目录/通过一个文件描述符改变当前工作目录
        chroot()               # 改变当前进程的根目录
        listdir()              # 列出指定目录的文件
        getcwd()/getcwdu()     # 返回当前工作目录/功能相同,但返回一个unicode对象
        mkdir()/makedirs()     # 创建目录/创建多层目录
        rmdir()/removedirs()   # 删除目录/删除多层目录

    访问/权限
        saccess()                    # 检验权限模式
        chmod(&apos;txt&apos;,eval(&quot;0777&quot;))    # 改变权限模式
        chown()/lchown()             # 改变owner和groupID功能相同,但不会跟踪链接
        umask()                      # 设置默认权限模式

    文件描述符操作
        open()                 # 底层的操作系统open(对于稳健,使用标准的内建open()函数)
        read()/write()         # 根据文件描述符读取/写入数据 按大小读取文件部分内容
        dup()/dup2()           # 复制文件描述符号/功能相同,但是复制到另一个文件描述符

    设备号
        makedev()              # 从major和minor设备号创建一个原始设备号
        major()/minor()        # 从原始设备号获得major/minor设备号

    os.path模块

        os.path.expanduser(&apos;~/.ssh/key&apos;)   # 家目录下文件的全路径

        分隔
            os.path.basename()         # 去掉目录路径,返回文件名
            os.path.dirname()          # 去掉文件名,返回目录路径
            os.path.join()             # 将分离的各部分组合成一个路径名
            os.path.spllt()            # 返回(dirname(),basename())元组
            os.path.splitdrive()       # 返回(drivename,pathname)元组
            os.path.splitext()         # 返回(filename,extension)元组

        信息
            os.path.getatime()         # 返回最近访问时间
            os.path.getctime()         # 返回文件创建时间
            os.path.getmtime()         # 返回最近文件修改时间
            os.path.getsize()          # 返回文件大小(字节)

        查询
            os.path.exists()           # 指定路径(文件或目录)是否存在
            os.path.isabs()            # 指定路径是否为绝对路径
            os.path.isdir()            # 指定路径是否存在且为一个目录
            os.path.isfile()           # 指定路径是否存在且为一个文件
            os.path.islink()           # 指定路径是否存在且为一个符号链接
            os.path.ismount()          # 指定路径是否存在且为一个挂载点
            os.path.samefile()         # 两个路径名是否指向同一个文件

    子进程
        os.fork()    # 创建子进程,并复制父进程所有操作  通过判断pid = os.fork() 的pid值,分别执行父进程与子进程操作，0为子进程
        os.wait()    # 等待子进程结束

    跨平台os模块属性

        linesep         # 用于在文件中分隔行的字符串
        sep             # 用来分隔文件路径名字的字符串
        pathsep         # 用于分割文件路径的字符串
        curdir          # 当前工作目录的字符串名称
        pardir          # 父目录字符串名称

    磁盘空间

        import os
        disk = os.statvfs(&quot;/&quot;)
        # disk.f_bsize       块大小
        # disk.f_blocks      块总数
        # disk.f_bfree       剩余块总数
        # disk.f_bavail      非root用户的剩余块数  由于权限小会比root的剩余块总数小 用这个做报警会更准确
        # disk.f_files       总节点数
        # disk.f_ffree       剩余节点数
        # disk.f_favail      非root用户的剩余节点数

        disk.f_bsize * disk.f_bavail / 1024 / 1024 / 1024   # 非root用户剩余空间大小G
        disk.f_bsize * disk.f_blocks / 1024 / 1024 / 1024   # 分区空间总大小

commands        [执行系统命令]

    (status, output) = commands.getstatusoutput(&apos;cat /proc/cpuinfo&apos;)
    print status, output
    commands.getstatusoutput(&apos;id&apos;)       # 返回元组(状态,标准输出)
    commands.getoutput(&apos;id&apos;)             # 只返回执行的结果, 忽略返回值
    commands.getstatus(&apos;file&apos;)           # 返回ls -ld file执行的结果

re              [perl风格正则]

    compile(pattern,flags=0)          # 对正则表达式模式pattern进行编译,flags是可选标识符,并返回一个regex对象
    match(pattern,string,flags=0)     # 尝试用正则表达式模式pattern匹配字符串string,flags是可选标识符,如果匹配成功,则返回一个匹配对象;否则返回None
    search(pattern,string,flags=0)    # 在字符串string中搜索正则表达式模式pattern的第一次出现,flags是可选标识符,如果匹配成功,则返回一个匹配对象;否则返回None
    findall(pattern,string[,flags])   # 在字符串string中搜索正则表达式模式pattern的所有(非重复)出现:返回一个匹配对象的列表  # pattern=u&apos;\u4e2d\u6587&apos; 代表UNICODE
    finditer(pattern,string[,flags])  # 和findall()相同,但返回的不是列表而是迭代器;对于每个匹配,该迭代器返回一个匹配对象
    split(pattern,string,max=0)       # 根据正则表达式pattern中的分隔符把字符string分割为一个列表,返回成功匹配的列表,最多分割max次(默认所有)
    sub(pattern,repl,string,max=0)    # 把字符串string中所有匹配正则表达式pattern的地方替换成字符串repl,如果max的值没有给出,则对所有匹配的地方进行替换(subn()会返回一个表示替换次数的数值)
    group(num=0)                      # 返回全部匹配对象(或指定编号是num的子组)
    groups()                          # 返回一个包含全部匹配的子组的元组(如果没匹配成功,返回一个空元组)

    零宽断言
        str = &apos;aaa111aaa , bbb222&amp;, 333ccc&apos;
        re.compile(&apos;\d+(?=[a-z]+)&apos;).findall(str)          # 前向界定 (?=exp) 找出连续的数字并且最后一个数字跟着至少一个a-z [&apos;111&apos;, &apos;333&apos;]
        re.compile(r&quot;\d+(?![a-z]+)&quot;).findall(str)         # 前向否定界定 (?!exp)  找出连续数字，且最后一个数字后不能跟a-z  [&apos;11&apos;, &apos;222&apos;, &apos;33&apos;]
        re.compile(r&quot;(?&lt;=[a-z])\d+&quot;).findall(str)         # 反向界定 (?&lt;=exp) 逆序环视 找出连续的数字，且第一个数字前面是a-z  [&apos;111&apos;, &apos;222&apos;]
        re.compile(r&quot;(?&lt;![a-z])\d+&quot;).findall(str)         # 反向否定界定 (?&lt;!exp) 否定逆序环视  找出连续的数字，且第一个数字前不能是a-z  [&apos;11&apos;, &apos;22&apos;, &apos;333&apos;]
        re.compile(r&quot;(?:\d+)&quot;).findall(str)               # 无捕获的匹配 (?:exp)
        s= &apos;Tom:9527 , Sharry:0003 &apos;
        re.match( r&apos;(?P&lt;name&gt;\w+):(?P&lt;num&gt;\d+)&apos; , s).group(0)   # 捕获组 &lt;num&gt;第二个标签变量[9527] 获取 group(&quot;num&quot;) 等同 group(2)[9527], group(0)全部[Tom:9527]

    例子
        re.findall(r&apos;a[be]c&apos;,&apos;123abc456eaec789&apos;)         # 返回匹配对象列表 [&apos;abc&apos;, &apos;aec&apos;]
        re.findall(&quot;(.)12[34](..)&quot;,a)                    # 取出匹配括号中内容   a=&apos;qedqwe123dsf&apos;
        re.search(&quot;(.)123&quot;,a ).group(1)                  # 搜索匹配的取第1个标签
        re.match(&quot;^(1|2) *(.*) *abc$&quot;, str).group(2)     # 取第二个标签
        re.match(&quot;^(1|2) *(.*) *abc$&quot;, str).groups()     # 取所有标签
        re.sub(&apos;[abc]&apos;,&apos;A&apos;,&apos;alex&apos;)                       # 替换
        for i in re.finditer(r&apos;\d+&apos;,s):                  # 迭代
            print i.group(),i.span()                     #

    搜索网页中UNICODE格式的中文
        QueryAdd=&apos;http://www.anti-spam.org.cn/Rbl/Query/Result&apos;
        Ip=&apos;222.129.184.52&apos;
        s = requests.post(url=QueryAdd, data={&apos;IP&apos;:Ip})
        re.findall(u&apos;\u4e2d\u56fd&apos;, s.text, re.S)

csv             [访问csv逗号分隔的文件]

    csv读配置文件

        192.168.1.5,web # 配置文件按逗号分割
        list = csv.reader(file(&apos;a.csv&apos;))
        for line in list:
            print line              #  [&apos;192.168.1.5&apos;, &apos;web&apos;]

    csv配合with读文件

        import csv
        with open(&apos;some.csv&apos;, &apos;rb&apos;) as f:
            reader = csv.reader(f)
            for row in reader:
                print row

    csv配合with写文件

        import csv
        with open(&apos;some.csv&apos;, &apos;wb&apos;) as f:
            writer = csv.writer(f)
            writer.writerow([&apos;Column1&apos;, &apos;Column2&apos;, &apos;Column3&apos;])    # 写单行 列表
            writer.writerows([range(3) for i in range(5)])        # 写多行 列表套列表

shutil          [提供高级文件访问功能]

    import shutil
    shutil.copyfile(&apos;data.db&apos;, &apos;archive.db&apos;)             # 拷贝文件
    shutil.move(&apos;/build/executables&apos;, &apos;installdir&apos;)      # 移动文件或目录

dircache        [目录文件列表缓存]

    import dircache
    a = dircache.listdir(&apos;/data/xuesong&apos;)        # 列出目录下所有的文件和目录
    dircache.annotate(&apos;/data/xuesong&apos;, a)        # 判断指定目录下的是文件还是目录,目录则后面加/ 文件或不存在则不改变

glob            [文件通配符]

    import glob
    glob.glob(&apos;*.py&apos;)    # 查找当前目录下py结尾的文件

random          [随机模块]

    import random
    random.choice([&apos;apple&apos;, &apos;pear&apos;, &apos;banana&apos;])   # 随机取列表一个参数
    random.sample(xrange(100), 10)  # 不重复抽取10个
    random.random()                 # 随机浮点数
    random.randrange(6)             # 随机整数范围

tempfile        [创建临时文件]

    import os
    import tempfile

    temp = tempfile.TemporaryFile()                # 定义一个临时文件对象
    try:
        temp.write(&apos;Some data&apos;)                    # 写入数据
        temp.writelines([&apos;first\n&apos;, &apos;second\n&apos;])   # 写入多行
        temp.seek(0)                               # 写入

        print temp.read()                          # 读取

        for line in temp:                          # 循环读取每一行
            print line.rstrip()
    finally:
        temp.close()                               # 关闭后删除临时文件



    # 创建临时目录
    import os
    import tempfile

    directory_name = tempfile.mkdtemp()
    print directory_name                            # 打印临时目录地址 /var/folders...
    # Clean up the directory yourself
    os.removedirs(directory_name)                   # 创建临时目录需要手动删除


    # 控制临时文件名
    import tempfile

    temp = tempfile.NamedTemporaryFile(suffix=&apos;_suffix&apos;,  prefix=&apos;prefix_&apos;,  dir=&apos;/tmp&apos;)
    try:
        print &apos;temp:&apos;, temp
        print &apos;temp.name:&apos;, temp.name
    finally:
        temp.close()

email           [发送邮件]

    发送邮件内容

        #!/usr/bin/python
        #encoding:utf8
        # 导入 smtplib 和 MIMEText
        import smtplib
        from email.mime.text import MIMEText

        # 定义发送列表
        mailto_list=[&quot;272121935@qq.com&quot;,&quot;272121935@163.com&quot;]

        # 设置服务器名称、用户名、密码以及邮件后缀
        mail_host = &quot;smtp.163.com&quot;
        mail_user = &quot;mailuser&quot;
        mail_pass = &quot;password&quot;
        mail_postfix=&quot;163.com&quot;

        # 发送邮件函数
        def send_mail(to_list, sub):
            me = mail_user + &quot;&lt;&quot;+mail_user+&quot;@&quot;+mail_postfix+&quot;&gt;&quot;
            fp = open(&apos;context.txt&apos;)
            msg = MIMEText(fp.read(),_charset=&quot;utf-8&quot;)
            fp.close()
            msg[&apos;Subject&apos;] = sub
            msg[&apos;From&apos;] = me
            msg[&apos;To&apos;] = &quot;;&quot;.join(to_list)
            try:
                send_smtp = smtplib.SMTP()
                send_smtp.connect(mail_host)
                send_smtp.login(mail_user+&quot;@&quot;+mail_postfix, mail_pass)
                send_smtp.sendmail(me, to_list, msg.as_string())
                send_smtp.close()
                return True
            except Exception, e:
                print str(e)
                return False

        if send_mail(mailto_list,&quot;标题&quot;):
            print &quot;测试成功&quot;
        else:
            print &quot;测试失败&quot;

    发送附件

        #!/usr/bin/python
        #encoding:utf8
        import smtplib
        from email.mime.multipart import MIMEMultipart
        from email.mime.base import MIMEBase
        from email import encoders

        def send_mail(to_list, sub, filename):
            me = mail_user + &quot;&lt;&quot;+mail_user+&quot;@&quot;+mail_postfix+&quot;&gt;&quot;
            msg = MIMEMultipart()
            msg[&apos;Subject&apos;] = sub
            msg[&apos;From&apos;] = me
            msg[&apos;To&apos;] = &quot;;&quot;.join(to_list)
            submsg = MIMEBase(&apos;application&apos;, &apos;x-xz&apos;)
            submsg.set_payload(open(filename,&apos;rb&apos;).read())
            encoders.encode_base64(submsg)
            submsg.add_header(&apos;Content-Disposition&apos;, &apos;attachment&apos;, filename=filename)
            msg.attach(submsg)
            try:
                send_smtp = smtplib.SMTP()
                send_smtp.connect(mail_host)
                send_smtp.login(mail_user, mail_pass)
                send_smtp.sendmail(me, to_list, msg.as_string())
                send_smtp.close()
                return True
            except Exception, e:
                print str(e)[1]
                return False

        # 设置服务器名称、用户名、密码以及邮件后缀
        mail_host = &quot;smtp.163.com&quot;
        mail_user = &quot;xuesong&quot;
        mail_pass = &quot;mailpasswd&quot;
        mail_postfix = &quot;163.com&quot;
        mailto_list = [&quot;272121935@qq.com&quot;,&quot;quanzhou722@163.com&quot;]
        title = &apos;check&apos;
        filename = &apos;file_check.html&apos;
        if send_mail(mailto_list,title,filename):
            print &quot;发送成功&quot;
        else:
            print &quot;发送失败&quot;

gzip            [解压缩gzip 删除原文件]

    #压缩gzip
    import gzip
    f_in = open(&apos;file.log&apos;, &apos;rb&apos;)
    f_out = gzip.open(&apos;file.log.gz&apos;, &apos;wb&apos;)
    f_out.writelines(f_in)
    f_out.close()
    f_in.close()

    #压缩gzip
    File = &apos;xuesong_18.log&apos;
    g = gzip.GzipFile(filename=&quot;&quot;, mode=&apos;wb&apos;, compresslevel=9, fileobj=open((r&apos;%s.gz&apos; %File),&apos;wb&apos;))
    g.write(open(r&apos;%s&apos; %File).read())
    g.close()

    #解压gzip
    g = gzip.GzipFile(mode=&apos;rb&apos;, fileobj=open((r&apos;xuesong_18.log.gz&apos;),&apos;rb&apos;))
    open((r&apos;xuesong_18.log&apos;),&apos;wb&apos;).write(g.read())

tarfile         [归档压缩tar.gz 保留原文件]

    # 压缩tar.gz
    import os
    import tarfile
    tar = tarfile.open(&quot;/tmp/tartest.tar.gz&quot;,&quot;w:gz&quot;)   # 创建压缩包名
    for path,dir,files in os.walk(&quot;/tmp/tartest&quot;):     # 递归文件目录
        for file in files:
            fullpath = os.path.join(path,file)
            tar.add(fullpath)                          # 创建压缩包
    tar.close()

    # 解压tar.gz
    import tarfile
    tar = tarfile.open(&quot;/tmp/tartest.tar.gz&quot;)
    #tar.extract(&quot;/tmp&quot;)                               # 全部解压到指定路径
    names = tar.getnames()                             # 包内文件名
    for name in names:
        tar.extract(name,path=&quot;./&quot;)                    # 解压指定文件
    tar.close()

zipfile         [解压缩zip 最大2G]

    # 压缩zip
    import zipfile,os
    f = zipfile.ZipFile(&apos;filename.zip&apos;, &apos;w&apos; ,zipfile.ZIP_DEFLATED)    # ZIP_STORE 为默认表不压缩. ZIP_DEFLATED 表压缩
    #f.write(&apos;file1.txt&apos;)                              # 将文件写入压缩包
    for path,dir,files in os.walk(&quot;tartest&quot;):          # 递归压缩目录
        for file in files:
            f.write(os.path.join(path,file))           # 将文件逐个写入压缩包
    f.close()

    # 解压zip
    if zipfile.is_zipfile(&apos;filename.zip&apos;):             # 判断一个文件是不是zip文件
        f = zipfile.ZipFile(&apos;filename.zip&apos;)
        for file in f.namelist():                      # 返回文件列表
            f.extract(file, r&apos;/tmp/&apos;)                  # 解压指定文件
        #f.extractall()                                # 解压全部
        f.close()

time/datetime   [时间]

    import time
    time.strftime(&apos;%Y%m%d_%H%M&apos;)         # 格式化时间
    time.time()                          # 时间戳[浮点]
    int(time.time())                     # 时间戳[整s]
    time.localtime()[1] - 1              # 上个月
    time.strftime(&apos;%Y-%m-%d_%X&apos;,time.localtime( time.time() ) )              # 时间戳转日期
    time.mktime(time.strptime(&apos;2012-03-28 06:53:40&apos;, &apos;%Y-%m-%d %H:%M:%S&apos;))   # 日期转时间戳

    最近的周五

        from datetime import datetime
        from dateutil.relativedelta import relativedelta, FR
        (datetime.now() + relativedelta(weekday=FR(-1))).strftime(&apos;%Y%m%d&apos;)

    获取本周一
        import  datetime
        datetime.date.today() - datetime.timedelta(days=datetime.date.today().weekday())

    判断输入时间格式是否正确

        #encoding:utf8
        import time
        while 1:
            atime=raw_input(&apos;输入格式如[14.05.13 13:00]:&apos;)
            try:
                btime=time.mktime(time.strptime(&apos;%s:00&apos; %atime, &apos;%y.%m.%d %H:%M:%S&apos;))
                break
            except:
                print &apos;时间输入错误,请重新输入，格式如[14.05.13 13:00]&apos;

    上一个月最后一天
        import datetime
        lastMonth=datetime.date(datetime.date.today().year,datetime.date.today().month,1)-datetime.timedelta(1)
        lastMonth.strftime(&quot;%Y/%m&quot;)

    前一天
        (datetime.datetime.now() + datetime.timedelta(days=-1) ).strftime(&apos;%Y%m%d&apos;)

    两日期相差天数

        import datetime
        d1 = datetime.datetime(2005, 2, 16)
        d2 = datetime.datetime(2004, 12, 31)
        (d1 - d2).days

    向后加10个小时

        import datetime
        d1 = datetime.datetime.now()
        d3 = d1 + datetime.timedelta(hours=10)
        d3.ctime()

optparse        [解析参数及标准提示]

    import os, sys
    import time
    import optparse
    # python aaa.py -t file -p /etc/opt -o aaaaa

    def do_fiotest( type, path, output,):
        print type, path, output,

    def main():
        parser = optparse.OptionParser()
        parser.add_option(&apos;-t&apos;, &apos;--type&apos;, dest = &apos;type&apos;, default = None, help = &apos;test type[file, device]&apos;)
        parser.add_option(&apos;-p&apos;, &apos;--path&apos;, dest = &apos;path&apos;, default = None, help = &apos;test file path or device path&apos;)
        parser.add_option(&apos;-o&apos;, &apos;--output&apos;, dest = &apos;output&apos;, default = None, help = &apos;result dir path&apos;)

        (o, a) = parser.parse_args()

        if None == o.type or None == o.path or None == o.output:
            print &quot;No device or file or output dir&quot;
            return -1

        if &apos;file&apos; != o.type and &apos;device&apos; != o.type:
            print &quot;You need specify test type [&apos;file&apos; or &apos;device&apos;]&quot;
            return -1

        do_fiotest(o.type, o.path, o.output)
        print &quot;Test done!&quot;


    if __name__ == &apos;__main__&apos;:
        main()

getopt          [解析参数]

    import sys,os
    import getopt

    try:
        options,argsErr = getopt.getopt(sys.argv[1:],&quot;hu:c:&quot;,[&quot;help&quot;,&quot;user=&quot;,&quot;cmd=&quot;])    # 中间短参数，后面长参数对应. 不带:或=代表不带参数
    except getopt.GetoptError:
        print &quot;Unknown parameters,More info with: %s -h&quot; %(sys.argv[0])
        sys.exit(2)
    if argsErr != []:
        print &quot;Unknown parameters,More info with: %s -h&quot; %(sys.argv[0])
        sys.exit(2)

    for o,a in  options:
        if o in (&quot;-h&quot;,&quot;--help&quot;):
            print &apos;&apos;&apos;Usage: python te.py -u user -c &quot;cmd -options&quot; &apos;&apos;&apos;
            sys.exit(2)
        if o in (&quot;-u&quot;,&quot;--user&quot;):
            user = a
        if o in (&quot;-c&quot;,&quot;--cmd&quot;):
            cmd = a
    print user,cmd

argparse        [命令行选项和参数解析库]

    import argparse
    parser = argparse.ArgumentParser( prog=&apos;usage_name&apos;, description=&apos;开头打印&apos;, epilog=&quot;结束打印&quot;)
    parser.add_argument(&apos;-f&apos;, &apos;--foo&apos;, help=&apos;foo help&apos;, action=&apos;append&apos;)      # 可选参数,如使用此参数必须传值 action=&apos;store_true&apos; 不加参数为True  action=&apos;append&apos; 多个参数可叠加为列表
    parser.add_argument(&apos;--aa&apos;, type=int, default=42, help=&apos;aa!&apos;)             # type规定参数类型,default设置默认值
    parser.add_argument(&apos;bar&apos;, nargs=&apos;*&apos;, default=[1, 2, 3], help=&apos;BAR!&apos;)     # 位置参数 必须传递  nargs=2 需要传递2个参数
    parser.add_argument(&apos;args&apos;, nargs=argparse.REMAINDER)                     # 剩余参数收集到列表
    parser.print_help()                                                       # 打印使用帮助
    #parser.parse_args(&apos;BAR --foo FOO&apos;.split())                               # 设置位置参数
    args = parser.parse_args()                                                # 全部的值
    parser.get_default(&apos;foo&apos;)                                                 # 获取

    python a.py --foo ww  --aa 40 xuesong 27                                  # 执行此脚本

subprocess      [子进程管理]

    import subprocess
    s=subprocess.Popen(&apos;sleep 20&apos;, shell=True, \
            stdin = subprocess.PIPE, stdout = subprocess.PIPE, stderr = subprocess.PIPE)
    print s.wait()         # 阻塞等待子进程完成并返回状态码 shell 0为正确  但管道内容过多会造成死锁可以用 communicate()
    print s.stdout.read()
    print s.stderr.read()

    print s.communicate()     # 返回元组 (stdout, stderr)  会阻塞等待进程完成 推荐使用
    print s.returncode        # 返回执行状态码

base64          [编码]

    # 简单但容易被直接破解
    import base64
    s1 = base64.encodestring(&apos;hello world&apos;)
    s2 = base64.decodestring(s1)

uu              [对文件uu编码]

    import uu
    uu.encode(&apos;in_file&apos;,&apos;out_file&apos;)       # 编码
    uu.decode(&apos;in_file&apos;,&apos;out_file&apos;)       # 解码

binascii        [ascii和二进制编码转换]

md5             [单向MD5加密]

    import md5
    m = md5.new(&apos;123456&apos;).hexdigest()

hashlib         [hash算法库]

    import hashlib
    m = hashlib.md5()
    m.update(&quot;Nobody inspects&quot;)    # 使用update方法对字符串md5加密
    m.digest()                     # 加密后二进制结果
    m.hexdigest()                  # 加密后十进制结果
    hashlib.new(&quot;md5&quot;, &quot;string&quot;).hexdigest()               # 对字符串加密
    hashlib.new(&quot;md5&quot;, open(&quot;file&quot;).read()).hexdigest()    # 查看文件MD5值

    hashlib.sha224(&quot;Nobody inspects the spammish repetition&quot;).hexdigest()       # 几种hash算法 sha1  sha224  sha256  sha384  ha512

crypt           [单向加密]

    import crypt
    import random,string

    def getsalt(chars = string.letters+string.digits):
        return random.choice(chars)+random.choice(chars)
    salt = getsalt()
    print salt
    print crypt.crypt(&apos;bananas&apos;,salt)

pycrypto        [加密]

    # https://github.com/dlitz/pycrypto
    SHA256  # 不可逆散列算法加密
        from Crypto.Hash import SHA256
        hash = SHA256.new()
        hash.update(&apos;message&apos;)
        hash.digest()

    AES     # 可逆加密,需要密钥
        from Crypto.Cipher import AES
        obj = AES.new(&apos;This is a key123&apos;, AES.MODE_CBC, &apos;This is an IV456&apos;)
        message = &quot;The answer is no&quot;
        ciphertext = obj.encrypt(message)
        ciphertext
        &apos;\xd6\x83\x8dd!VT\x92\xaa`A\x05\xe0\x9b\x8b\xf1&apos;
        obj2 = AES.new(&apos;This is a key123&apos;, AES.MODE_CBC, &apos;This is an IV456&apos;)
        obj2.decrypt(ciphertext)
        &apos;The answer is no&apos;

rsa             [公钥加密算法]

    http://www.heikkitoivonen.net/m2crypto/api/M2Crypto.RSA.RSA-class.html

    pip install M2Crypto

    from M2Crypto import RSA,BIO                         # help(RSA)
    rsa = RSA.gen_key(2048, &apos;sha1&apos;)                      # 设置生成密钥为2048位,1024较不安全,默认算法sha1
    rsa.save_key(&apos;rsa.priv.pem&apos;, None )                  # 生成私钥pem文件
    rsa.save_pub_key(&apos;rsa.pub.pem&apos;)                      # 生成公钥pem文件
    rsa.save_key_bio()                                   # 私钥保存到pem格式的M2Crypto.BIO.BIO对象
    rsa.save_pub_key_bio()                               # 公钥保存到pem格式的M2Crypto.BIO.BIO对象
    priv=RSA.load_key(&apos;rsa.priv.pem&apos;)                    # 加载私钥文件
    pub=RSA.load_pub_key(&apos;rsa.pub.pem&apos;)                  # 加载公钥文件
    rsa.check_key()                                      # 检查key是否初始化
    pub_key.public_encrypt(&apos;data&apos;,RSA.pkcs1_padding)     # 公钥加密
    priv_key.private_decrypt(&apos;密文&apos;,RSA.pkcs1_padding)   # 私钥解密

    from M2Crypto import RSA,BIO

    rsa = RSA.gen_key(2048, 3, lambda *agr:None)
    pub_bio = BIO.MemoryBuffer()
    priv_bio = BIO.MemoryBuffer()

    rsa.save_pub_key_bio(pub_bio)
    rsa.save_key_bio(priv_bio, None)

    # print pub_bio.read_all()
    pub_key = RSA.load_pub_key_bio(pub_bio)
    priv_key = RSA.load_key_bio(priv_bio)

    message = &apos;i am luchanghong&apos;

    encrypted = pub_key.public_encrypt(message, RSA.pkcs1_padding)        # 加密
    decrypted = priv_key.private_decrypt(encrypted, RSA.pkcs1_padding)    # 解密

    print decrypted

getpass         [隐藏输入密码]

    import getpass
    passwd=getpass.getpass()

string          [字符串类]

    import string
    string.ascii_letters   # a-zA-Z  ascii的不受语言系统环境变化
    string.ascii_lowercase # a-z
    string.letters         # a-zA-Z  受系统语言环境变化影响
    string.lowercase       # a-z
    string.uppercase       # A-Z大小
    string.digits          # 0-9
    string.printable       # 所有字符
    string.whitespace      # 空白字符

Gittle          [python的git库]

    pip install gittle
    from gittle import Gittle
    repo_path = &apos;/tmp/gittle_bare&apos;
    repo_url = &apos;git://github.com/FriendCode/gittle.git&apos;
    repo = Gittle.clone(repo_url, repo_path)
    auth = GittleAuth(pkey=key)                           # 认证
    Gittle.clone(repo_url, repo_path, auth=auth)
    repo = Gittle.clone(repo_url, repo_path, bare=True)   # 克隆仓库没有目录的
    repo = Gittle.init(path)                     # 初始化
    repo.commits                                 # 获取提交列表
    repo.branches                                # 获取分支列表
    repo.modified_files                          # 被修改的文件列表
    repo.diff(&apos;HEAD&apos;, &apos;HEAD~1&apos;)                  # 获取最新提交差异
    repo.stage(&apos;file.txt&apos;)                       # 提交文件
    repo.stage([&apos;other1.txt&apos;, &apos;other2.txt&apos;])     # 提交文件列表
    repo.commit(name=&quot;Samy Pesse&quot;, email=&quot;samy@friendco.de&quot;, message=&quot;This is a commit&quot;)  # 更新信息

    repo = Gittle(repo_path, origin_uri=repo_url)
    key_file = open(&apos;/Users/Me/keys/rsa/private_rsa&apos;)
    repo.auth(pkey=key_file)
    repo.push()                                   # 远端push提交操作

    repo = Gittle(repo_path, origin_uri=repo_url)
    key_file = open(&apos;/Users/Me/keys/rsa/private_rsa&apos;)
    repo.auth(pkey=key_file)
    repo.pull()                                   # 拉取最新分支

    repo.create_branch(&apos;dev&apos;, &apos;master&apos;)           # 创建分支
    repo.switch_branch(&apos;dev&apos;)                     # 切换到分支
    repo.create_orphan_branch(&apos;NewBranchName&apos;)    # 创建一个空的分支
    repo.remove_branch(&apos;dev&apos;)                     # 删除分支


paramiko        [ssh客户端]

    安装
        sudo apt-get install python-setuptools
        easy_install
        sudo apt-get install python-all-dev
        sudo apt-get install build-essential

    paramiko实例(账号密码登录执行命令)

        #!/usr/bin/python
        #ssh
        import paramiko
        import sys,os

        host = &apos;10.152.15.200&apos;
        user = &apos;peterli&apos;
        password = &apos;123456&apos;

        s = paramiko.SSHClient()                                 # 绑定实例
        s.load_system_host_keys()                                # 加载本地HOST主机文件
        s.set_missing_host_key_policy(paramiko.AutoAddPolicy())  # 允许连接不在know_hosts文件中的主机
        s.connect(host,22,user,password,timeout=5)               # 连接远程主机
        while True:
                cmd=raw_input(&apos;cmd:&apos;)
                stdin,stdout,stderr = s.exec_command(cmd)        # 执行命令
                cmd_result = stdout.read(),stderr.read()         # 读取命令结果
                for line in cmd_result:
                        print line,
        s.close()

    paramiko实例(传送文件)

        #!/usr/bin/evn python
        import os
        import paramiko
        host=&apos;127.0.0.1&apos;
        port=22
        username = &apos;peterli&apos;
        password = &apos;123456&apos;
        ssh=paramiko.Transport((host,port))
        privatekeyfile = os.path.expanduser(&apos;~/.ssh/id_rsa&apos;)
        mykey = paramiko.RSAKey.from_private_key_file( os.path.expanduser(&apos;~/.ssh/id_rsa&apos;))   # 加载key 不使用key可不加
        ssh.connect(username=username,password=password)           # 连接远程主机
        # 使用key把 password=password 换成 pkey=mykey
        sftp=paramiko.SFTPClient.from_transport(ssh)               # SFTP使用Transport通道
        sftp.get(&apos;/etc/passwd&apos;,&apos;pwd1&apos;)                             # 下载 两端都要指定文件名
        sftp.put(&apos;pwd&apos;,&apos;/tmp/pwd&apos;)                                 # 上传
        sftp.close()
        ssh.close()

    paramiko实例(密钥执行命令)

        #!/usr/bin/python
        #ssh
        import paramiko
        import sys,os
        host = &apos;10.152.15.123&apos;
        user = &apos;peterli&apos;
        s = paramiko.SSHClient()
        s.load_system_host_keys()
        s.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        privatekeyfile = os.path.expanduser(&apos;~/.ssh/id_rsa&apos;)             # 定义key路径
        mykey = paramiko.RSAKey.from_private_key_file(privatekeyfile)
        # mykey=paramiko.DSSKey.from_private_key_file(privatekeyfile,password=&apos;061128&apos;)   # DSSKey方式 password是key的密码
        s.connect(host,22,user,pkey=mykey,timeout=5)
        cmd=raw_input(&apos;cmd:&apos;)
        stdin,stdout,stderr = s.exec_command(cmd)
        cmd_result = stdout.read(),stderr.read()
        for line in cmd_result:
                print line,
        s.close()

    ssh并发(Pool控制最大并发)

        #!/usr/bin/env python
        #encoding:utf8
        #ssh_concurrent.py

        import multiprocessing
        import sys,os,time
        import paramiko

        def ssh_cmd(host,port,user,passwd,cmd):
            msg = &quot;-----------Result:%s----------&quot; % host

            s = paramiko.SSHClient()
            s.load_system_host_keys()
            s.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            try:
                s.connect(host,22,user,passwd,timeout=5)
                stdin,stdout,stderr = s.exec_command(cmd)

                cmd_result = stdout.read(),stderr.read()
                print msg
                for line in cmd_result:
                        print line,

                s.close()
            except paramiko.AuthenticationException:
                print msg
                print &apos;AuthenticationException Failed&apos;
            except paramiko.BadHostKeyException:
                print msg
                print &quot;Bad host key&quot;

        result = []
        p = multiprocessing.Pool(processes=20)
        cmd=raw_input(&apos;CMD:&apos;)
        f=open(&apos;serverlist.conf&apos;)
        list = f.readlines()
        f.close()
        for IP in list:
            print IP
            host=IP.split()[0]
            port=int(IP.split()[1])
            user=IP.split()[2]
            passwd=IP.split()[3]
            result.append(p.apply_async(ssh_cmd,(host,port,user,passwd,cmd)))

        p.close()

        for res in result:
            res.get(timeout=35)

    ssh并发(取文件状态并发送邮件)

        #!/usr/bin/python
        #encoding:utf8
        #config file: ip.list

        import paramiko
        import multiprocessing
        import smtplib
        import sys,os,time,datetime,socket,re
        from email.mime.text import MIMEText

        # 配置文件(IP列表)
        Conf = &apos;ip.list&apos;
        user_name = &apos;peterli&apos;
        user_pwd = &apos;passwd&apos;
        port = 22
        PATH = &apos;/home/peterli/&apos;

        # 设置服务器名称、用户名、密码以及邮件后缀
        mail_host = &quot;smtp.163.com&quot;
        mail_user = &quot;xuesong&quot;
        mail_pass = &quot;mailpasswd&quot;
        mail_postfix = &quot;163.com&quot;
        mailto_list = [&quot;272121935@qq.com&quot;,&quot;quanzhou722@163.com&quot;]
        title = &apos;file check&apos;

        DATE1=(datetime.datetime.now() + datetime.timedelta(days=-1) ).strftime(&apos;%Y%m%d&apos;)
        file_path = &apos;%s%s&apos; %(PATH,DATE1)

        def Ssh_Cmd(file_path,host_ip,user_name,user_pwd,port=22):

            s = paramiko.SSHClient()
            s.load_system_host_keys()
            s.set_missing_host_key_policy(paramiko.AutoAddPolicy())

            try:
                s.connect(hostname=host_ip,port=port,username=user_name,password=user_pwd)
                stdin,stdout,stderr = s.exec_command(&apos;stat %s&apos; %file_path)
                stat_result = &apos;%s%s&apos; %(stdout.read(),stderr.read())
                if stat_result.find(&apos;No such file or directory&apos;) == -1:
                    file_status = &apos;OK\t&apos;
                    stdin,stdout,stderr = s.exec_command(&apos;du -sh %s&apos; %file_path)
                    cmd1_result = &apos;%s_%s&apos; %(stat_result.split()[32],stat_result.split()[33].split(&apos;.&apos;)[0])
                    cmd2_result = (&apos;%s%s&apos; %(stdout.read(),stderr.read())).split()[0]
                else:
                    file_status = &apos;未生成\t&apos;
                    cmd1_result = &apos;null&apos;
                    cmd2_result = &apos;null&apos;
                q.put([&apos;Login successful&apos;])
                s.close()
            except socket.error:
                file_status = &apos;主机或端口错误&apos;
                cmd1_result = &apos;-&apos;
                cmd2_result = &apos;-&apos;
            except paramiko.AuthenticationException:
                file_status = &apos;用户或密码错误&apos;
                cmd1_result = &apos;-&apos;
                cmd2_result = &apos;-&apos;
            except paramiko.BadHostKeyException:
                file_status = &apos;Bad host key&apos;
                cmd1_result = &apos;-&apos;
                cmd2_result = &apos;-&apos;
            except:
                file_status = &apos;ssh异常&apos;
                cmd1_result = &apos;-&apos;
                cmd2_result = &apos;-&apos;
            r.put(&apos;%s\t-\t%s\t%s\t%s\t%s\n&apos; %(time.strftime(&apos;%Y-%m-%d_%H:%M&apos;),host_ip,file_status,cmd2_result,cmd1_result))

        def Concurrent(Conf,file_path,user_name,user_pwd,port):
            # 执行总计
            total = 0
            # 读取配置文件
            f=open(Conf)
            list = f.readlines()
            f.close()
            # 并发执行
            process_list = []
            log_file = file(&apos;file_check.log&apos;, &apos;w&apos;)
            log_file.write(&apos;检查时间\t\t业务\tIP\t\t文件状态\t大小\t生成时间\n&apos;)
            for host_info in list:
                # 判断配置文件中注释行跳过
                if host_info.startswith(&apos;#&apos;):
                    continue
                # 取变量,其中任意变量未取到就跳过执行
                try:
                    host_ip=host_info.split()[0].strip()
                    #user_name=host_info.split()[1]
                    #user_pwd=host_info.split()[2]
                except:
                    log_file.write(&apos;Profile error: %s\n&apos; %(host_info))
                    continue
                #try:
                #    port=int(host_info.split()[3])
                #except:
                #    port=22
                total +=1
                p = multiprocessing.Process(target=Ssh_Cmd,args=(file_path,host_ip,user_name,user_pwd,port))
                p.start()
                process_list.append(p)
            for j in process_list:
                j.join()
            for j in process_list:
                log_file.write(r.get())

            successful = q.qsize()
            log_file.write(&apos;执行完毕。 总执行:%s 登录成功:%s 登录失败:%s\n&apos; %(total,successful,total - successful))
            log_file.flush()
            log_file.close()

        def send_mail(to_list, sub):
            me = mail_user + &quot;&lt;&quot;+mail_user+&quot;@&quot;+mail_postfix+&quot;&gt;&quot;
            fp = open(&apos;file_check.log&apos;)
            msg = MIMEText(fp.read(),_charset=&quot;utf-8&quot;)
            fp.close()
            msg[&apos;Subject&apos;] = sub
            msg[&apos;From&apos;] = me
            msg[&apos;To&apos;] = &quot;;&quot;.join(to_list)
            try:
                send_smtp = smtplib.SMTP()
                send_smtp.connect(mail_host)
                send_smtp.login(mail_user, mail_pass)
                send_smtp.sendmail(me, to_list, msg.as_string())
                send_smtp.close()
                return True
            except Exception, e:
                print str(e)[1]
                return False

        if __name__ == &apos;__main__&apos;:
            q = multiprocessing.Queue()
            r = multiprocessing.Queue()
            Concurrent(Conf,file_path,user_name,user_pwd,port)
            if send_mail(mailto_list,title):
                print &quot;发送成功&quot;
            else:
                print &quot;发送失败&quot;

pysnmp          [snmp客户端]

    #!/usr/bin/python
    from pysnmp.entity.rfc3413.oneliner import cmdgen

    cg = cmdgen.CommandGenerator()

    # 注意IP 端口 组默认public  oid值
    varBinds = cg.getCmd( cmdgen.CommunityData(&apos;any-agent&apos;, &apos;public&apos;,0 ), cmdgen.UdpTransportTarget((&apos;10.10.76.42&apos;, 161)),    (1,3,6,1,4,1,2021,10,1,3,1), )

    print varBinds[3][0][1]

PDB             [单步调试]

    # 很多程序因为被try了,看不到具体报错的地方, 用这个模块就很清晰可以看到错误的位置
    # http://docs.python.org/2/library/pdb.html

    (Pdb) h              # 帮助
    # 断点设置
    (Pdb)b 10            # 断点设置在本py的第10行
    (Pdb)b ots.py:20     # 断点设置到 ots.py第20行
    (Pdb)b               # 查看断点编号
    (Pdb)cl 2            # 删除第2个断点

    # 运行
    (Pdb)n               # 单步运行
    (Pdb)s               # 细点运行 也就是会下到，方法
    (Pdb)c               # 跳到下个断点
    # 查看
    (Pdb)p param         # 查看当前 变量值
    (Pdb)l               # 查看运行到某处代码
    (Pdb)a               # 查看全部栈内变量
    !a = 100             # 直接赋值

    python -m pdb myscript.py   # 直接对脚本单步调试

    # 在程序里面加单步调试
    import pdb
    def tt():
        pdb.set_trace()
        for i in range(1, 5):
            print i
    &gt;&gt;&gt; tt()
    &gt; &lt;stdin&gt;(3)tt()
    (Pdb) n              #这里支持 n p c 而已

pstats          [源码性能分析测试]

    import profile
    import pstats

    profile.run(&quot;run()&quot;, &quot;prof.txt&quot;)
    p = pstats.Stats(&quot;prof.txt&quot;)
    p.sort_stats(&quot;time&quot;).print_stats()

apscheduler     [任务调度]

    # 安装   pip install apscheduler
    # 例子   https://bitbucket.org/agronholm/apscheduler/src/e6298f953a68/tests/?at=master

    scheduler.start()                                                   # 启动任务
    job = scheduler.add_job(myfunc, &apos;interval&apos;, minutes=2)              # 添加任务
    job.remove()                                                        # 删除任务
    scheduler.add_job(myfunc, &apos;interval&apos;, minutes=2, id=&apos;my_job_id&apos;)    # 添加任务
    scheduler.remove_job(&apos;my_job_id&apos;)                                   # 删除任务
    job.modify(max_instances=6, name=&apos;Alternate name&apos;)                  # 修改工作
    scheduler.shutdown()                                                # 关闭调度
    scheduler.shutdown(wait=False)                                      # 关闭调度  不等待
    # 暂停
    apscheduler.job.Job.pause()
    apscheduler.schedulers.base.BaseScheduler.pause_job()
    # 恢复
    apscheduler.job.Job.resume()
    apscheduler.schedulers.base.BaseScheduler.resume_job()

    定时任务
        from pytz import utc
        from apscheduler.schedulers.background import BackgroundScheduler
        from apscheduler.executors.pool import ThreadPoolExecutor, ProcessPoolExecutor
        import time

        executors = {
            &apos;default&apos;: ThreadPoolExecutor(20),
            &apos;processpool&apos;: ProcessPoolExecutor(5)
        }
        job_defaults = {
            &apos;coalesce&apos;: False,
            &apos;max_instances&apos;: 3
        }
        scheduler = BackgroundScheduler( executors=executors, job_defaults=job_defaults, timezone=utc)

        def myfunc():
            print &apos;test&apos;

        scheduler.add_job(myfunc, &apos;interval&apos;, minutes=1, id=&apos;myworkid&apos;)
        scheduler.start()

        try:
            while True:
                time.sleep(2)
                # add_job
        except (KeyboardInterrupt, SystemExit):
            scheduler.shutdown()

logging         [日志记录]

    # 日志级别大小关系为: critical &gt; error &gt; warning &gt; info &gt; debug &gt; notset  也可自定义日志级别
    import logging
    logging.debug(&apos;debug&apos;)                 # 默认日志级别为 warning ,故debug日志不做打印
    logging.warning(&apos;warning&apos;)             # 达到默认日志级别为WARNING,打印到屏幕 warning
    logging.basicConfig                    # 通过logging.basicConfig函数对日志的输出格式及方式做相关配置
        # basicConfig 相关参数帮助
        filename               # 指定日志文件名
        filemode               # 和file函数意义相同，指定日志文件的打开模式，&apos;w&apos;或&apos;a&apos;
        datefmt                # 指定时间格式，同time.strftime()
        level                  # 设置日志级别，默认为logging.WARNING
        stream                 # 指定将日志的输出流，可以指定输出到sys.stderr,sys.stdout或者文件，默认输出到sys.stderr，当stream和filename同时指定时，stream被忽略
        format                 # 指定输出的格式和内容，format可以输出很多有用信息，如上例所示:
            %(levelno)s        # 打印日志级别的数值
            %(levelname)s      # 打印日志级别名称
            %(pathname)s       # 打印当前执行程序的路径，其实就是sys.argv[0]
            %(filename)s       # 打印当前执行程序名
            %(funcName)s       # 打印日志的当前函数
            %(lineno)d         # 打印日志的当前行号
            %(asctime)s        # 打印日志的时间
            %(thread)d         # 打印线程ID
            %(threadName)s     # 打印线程名称
            %(process)d        # 打印进程ID
            %(message)s        # 打印日志信息


    logging.config.fileConfig(&quot;logger.conf&quot;)        # 加载配置文件
    logger = logging.getLogger(&quot;example02&quot;)         # 使用已定义的日志记录器
    logger.conf                                     # 配置文件
        ###############################################
        [loggers]
        keys=root,example01,example02    # 设置三种日志记录器
        [logger_root]                    # 针对单一种设置
        level=DEBUG
        handlers=hand01,hand02
        [logger_example01]
        handlers=hand01,hand02           # 使用2中处理方式 应该是根据不同级别区分的
        qualname=example01
        propagate=0
        [logger_example02]
        handlers=hand01,hand03
        qualname=example02
        propagate=0
        ###############################################
        [handlers]                      # 不同的处理方式
        keys=hand01,hand02,hand03       # 三种方式的名字
        [handler_hand01]                # 第一种方式配置
        class=StreamHandler             # 发送错误信息到流
        level=INFO                      # 日志级别
        formatter=form02                # 日志的格式方式
        args=(sys.stderr,)
        [handler_hand02]
        class=FileHandler               # FileHandler写入磁盘文件
        level=DEBUG
        formatter=form01
        args=(&apos;myapp.log&apos;, &apos;a&apos;)         # 追加到日志文件
        [handler_hand03]
        class=handlers.RotatingFileHandler
        level=INFO
        formatter=form02
        args=(&apos;myapp.log&apos;, &apos;a&apos;, 10*1024*1024, 5)    # 追加日志并切割日志
        ###############################################
        [formatters]                                # 针对不同处理日志方式设置具体的日志格式
        keys=form01,form02
        [formatter_form01]
        format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s    # 日志列
        datefmt=%a, %d %b %Y %H:%M:%S               # 时间格式
        [formatter_form02]
        format=%(name)-12s: %(levelname)-8s %(message)s
        datefmt=


    通用日志记录
        import logging

        logging.basicConfig(level=logging.DEBUG,
                        format=&apos;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&apos;,
                        datefmt=&apos;%Y-%m-%d %H:%M:%S&apos;,
                        filename=&apos;/var/log/myapp.log&apos;,
                        filemode=&apos;a&apos;)
        # 日志级别DEBUG或高于DEBUG的会写入文件 myapp.log 中
        logging.debug(&apos;debug message&apos;)
        logging.info(&apos;info message&apos;)
        logging.warning(&apos;warning message&apos;)


ConfigParser    [配置解析]

    写入配置文件

        import ConfigParser
        config = ConfigParser.RawConfigParser()
        config.add_section(&apos;Section1&apos;)                          # 添加配置文件的块 [name]
        config.set(&apos;Section1&apos;, &apos;an_int&apos;, &apos;15&apos;)                  # 针对块设置配置参数和值
        config.set(&apos;Section1&apos;, &apos;a_bool&apos;, &apos;true&apos;)
        config.set(&apos;Section1&apos;, &apos;a_float&apos;, &apos;3.1415&apos;)
        config.set(&apos;Section1&apos;, &apos;baz&apos;, &apos;fun&apos;)
        config.set(&apos;Section1&apos;, &apos;bar&apos;, &apos;Python&apos;)
        config.set(&apos;Section1&apos;, &apos;foo&apos;, &apos;%(bar)s is %(baz)s!&apos;)
        with open(&apos;example.cfg&apos;, &apos;wb&apos;) as configfile:           # 指定配置文件路径
            config.write(configfile)                            # 写入配置文件

    读取配置文件

        import ConfigParser
        config = ConfigParser.RawConfigParser()
        config.read(&apos;example.cfg&apos;)                              # 读取配置文件
        a_float = config.getfloat(&apos;Section1&apos;, &apos;a_float&apos;)        # 获取配置文件参数对应的浮点值,如参数值类型不对则报ValueError
        an_int = config.getint(&apos;Section1&apos;, &apos;an_int&apos;)            # 获取配置文件参数对应的整数值,可直接进行计算
        print a_float + an_int
        if config.getboolean(&apos;Section1&apos;, &apos;a_bool&apos;):             # 根据配置文件参数值是否为真
            print config.get(&apos;Section1&apos;, &apos;foo&apos;)                 # 再获取依赖的配置参数 get获取后值为字符串
        print config.get(&apos;Section1&apos;, &apos;foo&apos;, 0)                  # 获取配置文件参数的同时加载变量[配置文件中的参数]
        print config.get(&apos;Section1&apos;, &apos;foo&apos;, 1)                  # 获取配置文件参数 原始值不做任何改动 不使用变量
        config.remove_option(&apos;Section1&apos;, &apos;bar&apos;)                 # 删除读取配置文件获取bar的值
        config.remove_option(&apos;Section1&apos;, &apos;baz&apos;)
        print config.get(&apos;Section1&apos;, &apos;foo&apos;, 0, {&apos;bar&apos;: &apos;str1&apos;, &apos;baz&apos;: &apos;str1&apos;})    # 读取配置参数的同时设置变量的值


    import ConfigParser
    import io

    sample_config = &quot;&quot;&quot;
    [mysqld]
    user = mysql
    pid-file = /var/run/mysqld/mysqld.pid
    skip-external-locking
    old_passwords = 1
    skip-bdb
    skip-innodb
    &quot;&quot;&quot;
    config = ConfigParser.RawConfigParser(allow_no_value=True)
    config.readfp(io.BytesIO(sample_config))
    config.get(&quot;mysqld&quot;, &quot;user&quot;)

ftplib          [ftp客户端]

    from ftplib import FTP
    ftp = FTP(&apos;ftp.debian.org&apos;)     # 连接ftp地址   FTP(host,port,timeout)
    ftp.login()                     # 使用默认anonymous登录  login(user,passwd)
    ftp.cwd(&apos;debian&apos;)               # 切换到目录debian
    ftp.retrlines(&apos;LIST&apos;)           # 打印目录列表
    ftp.retrbinary(&apos;RETR README&apos;, open(&apos;README&apos;, &apos;wb&apos;).write)       # 下载文件写到本地
    ftp.delete(&apos;filename&apos;)          # 删除ftp中文件
    ftp.mkd(&apos;dirname&apos;)              # 在ftp上创建目录
    ftp.size(&apos;filename&apos;)            # 查看文件大小
    ftp.quit()

difflib         [对象比较]

    import difflib
    s1 = [&apos;bacon\n&apos;, &apos;eggs\n&apos;, &apos;ham\n&apos;, &apos;guido\n&apos;]
    s2 = [&apos;python\n&apos;, &apos;eggy\n&apos;, &apos;hamster\n&apos;, &apos;guido\n&apos;]
    for line in difflib.context_diff(s1, s2, fromfile=&apos;txt-s1&apos;, tofile=&apos;txt-s2&apos;):    # 两字列表比较差异
        sys.stdout.write(line)

    difflib.get_close_matches(&apos;appel&apos;, [&apos;ape&apos;, &apos;apple&apos;, &apos;peach&apos;, &apos;puppy&apos;])           # 模糊匹配 匹配列表与字符串相似的值，越相似越靠前

heapq           [优先队列算法]

    from heapq import *
    h = []
    heappush(h, (5, &apos;write code&apos;))          # 放入队列
    heappush(h, (7, &apos;release product&apos;))
    heappush(h, (1, &apos;write spec&apos;))
    heappush(h, (3, &apos;create tests&apos;))
    heappop(h)                              # 从队列取出 第一次是1

    from heapq import *
    def heapsort(iterable):
        h = []
        for value in iterable:
            heappush(h, value)
        return [heappop(h) for i in range(len(h))]

    heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])

linecache       [随机读取指定行]

    import linecache
    linecache.getline(&apos;/etc/passwd&apos;, 4)

json            [数据交换格式]

    #!/usr/bin/python
    import json

    #json file temp.json
    #{ &quot;name&quot;:&quot;00_sample_case1&quot;, &quot;description&quot;:&quot;an example.&quot;}

    f = file(&quot;temp.json&quot;);
    s = json.load(f)        # 直接读取json文件
    print s
    f.close

    d = {&quot;a&quot;:1}
    j=json.dumps(d)  # 字典转json
    json.loads(j)    # json转字典

    s = json.loads(&apos;{&quot;name&quot;:&quot;test&quot;, &quot;type&quot;:{&quot;name&quot;:&quot;seq&quot;, &quot;parameter&quot;:[&quot;1&quot;, &quot;2&quot;]}}&apos;)
    print type(s)    # dic
    print s
    print s.keys()
    print s[&quot;type&quot;][&quot;parameter&quot;][1]

    json.dumps({&apos;ret&apos;:&apos;cmd_ret0&apos;, &apos;out&apos;:&apos;cmd_ret1&apos;}, separators=(&apos;,&apos;, &apos;:&apos;))    # 紧凑的json格式,去掉空格

filecmp         [文件目录比较]

    filecmp.cmp(&apos;/etc/passwd&apos;, &apos;/etc/passwd&apos;)     # 比较两文件是否一致

    # 比较两目录下文件是否一致
    from filecmp import dircmp
    def print_diff_files(dcmp):
        for name in dcmp.diff_files:
            print &quot;diff_file %s found in %s and %s&quot; % (name, dcmp.left, dcmp.right)
        for sub_dcmp in dcmp.subdirs.values():
            print_diff_files(sub_dcmp)

    dcmp = dircmp(&apos;dir1&apos;, &apos;dir2&apos;)
    print_diff_files(dcmp)

errno           [符号错误码]

    https://docs.python.org/2/library/errno.html#module-errno

    import errno

    try:
        fp = open(&quot;no.such.file&quot;)
    except IOError, (error, message):
        if error == errno.ENOENT:
            print &quot;no such file&quot;
        elif error == errno.EPERM:
            print &quot;permission denied&quot;
        else:
            print message

Exceptions      [标准异常类]

    # 详见官网 不需要导入
    https://docs.python.org/2/library/exceptions.html#module-exceptions

ctypes          [调用C的动态库]

    提供和C语言兼容的数据类型,也可调用C的动态库

    http://blog.csdn.net/linda1000/article/details/12623527
    http://www.cnblogs.com/wuchang/archive/2010/04/04/1704456.html
    http://www.ibm.com/developerworks/cn/linux/l-cn-pythonandc/

daemon          [守护进程]

    daemon.py

        # 创建守护进程的模块
        #!/usr/bin/env python

        import sys, os, time, atexit
        from signal import SIGTERM

        class Daemon:
            &quot;&quot;&quot;
            A generic daemon class.

            Usage: subclass the Daemon class and override the run() method
            &quot;&quot;&quot;
            def __init__(self, pidfile=&apos;nbMon.pid&apos;, stdin=&apos;/dev/null&apos;, stdout=&apos;nbMon.log&apos;, stderr=&apos;nbMon.log&apos;):
                self.stdin = stdin
                self.stdout = stdout
                self.stderr = stderr
                self.pidfile = pidfile

            def daemonize(self):
                &quot;&quot;&quot;
                do the UNIX double-fork magic, see Stevens&apos; &quot;Advanced
                Programming in the UNIX Environment&quot; for details (ISBN 0201563177)
                http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16
                &quot;&quot;&quot;
                try:
                    pid = os.fork()
                    if pid &gt; 0:
                        # exit first parent
                        sys.exit(0)
                except OSError, e:
                    sys.stderr.write(&quot;fork #1 failed: %d (%s)\n&quot; % (e.errno, e.strerror))
                    sys.exit(1)

                # decouple from parent environment
                #os.chdir(&quot;/&quot;)
                os.setsid()
                os.umask(0)

                # do second fork
                try:
                    pid = os.fork()
                    if pid &gt; 0:
                        # exit from second parent
                        sys.exit(0)
                except OSError, e:
                    sys.stderr.write(&quot;fork #2 failed: %d (%s)\n&quot; % (e.errno, e.strerror))
                    sys.exit(1)

                # redirect standard file descriptors
                sys.stdout.flush()
                sys.stderr.flush()
                si = file(self.stdin, &apos;r&apos;)
                so = file(self.stdout, &apos;a+&apos;)
                se = file(self.stderr, &apos;a+&apos;, 0)
                os.dup2(si.fileno(), sys.stdin.fileno())
                os.dup2(so.fileno(), sys.stdout.fileno())
                os.dup2(se.fileno(), sys.stderr.fileno())

                # write pidfile
                atexit.register(self.delpid)
                pid = str(os.getpid())
                file(self.pidfile,&apos;w+&apos;).write(&quot;%s\n&quot; % pid)

            def delpid(self):
                os.remove(self.pidfile)

            def start(self):
                &quot;&quot;&quot;
                Start the daemon
                &quot;&quot;&quot;
                # Check for a pidfile to see if the daemon already runs
                try:
                    pf = file(self.pidfile,&apos;r&apos;)
                    pid = int(pf.read().strip())
                    pf.close()
                except IOError:
                    pid = None

                if pid:
                    message = &quot;pidfile %s already exist. Daemon already running?\n&quot;
                    sys.stderr.write(message % self.pidfile)
                    sys.exit(1)

                # Start the daemon
                self.daemonize()
                self.run()

            def stop(self):
                &quot;&quot;&quot;
                Stop the daemon
                &quot;&quot;&quot;
                # Get the pid from the pidfile
                try:
                    pf = file(self.pidfile,&apos;r&apos;)
                    pid = int(pf.read().strip())
                    pf.close()
                except IOError:
                    pid = None

                if not pid:
                    message = &quot;pidfile %s does not exist. Daemon not running?\n&quot;
                    sys.stderr.write(message % self.pidfile)
                    return # not an error in a restart

                # Try killing the daemon process
                try:
                    while 1:
                        os.kill(pid, SIGTERM)
                        time.sleep(0.1)
                except OSError, err:
                    err = str(err)
                    if err.find(&quot;No such process&quot;) &gt; 0:
                        if os.path.exists(self.pidfile):
                            os.remove(self.pidfile)
                    else:
                        print str(err)
                        sys.exit(1)

            def restart(self):
                &quot;&quot;&quot;
                Restart the daemon
                &quot;&quot;&quot;
                self.stop()
                self.start()

            def run(self):
                &quot;&quot;&quot;
                You should override this method when you subclass Daemon. It will be called after the process has been
                daemonized by start() or restart().
                &quot;&quot;&quot;

    run_daemon.py

        # 启动脚本,倒入需要后台启动的模块,继承Daemon类,覆盖run函数
        # 启动方式  python run_daemon.py start

        #!/usr/bin/env python
        import Queue
        import threading
        import sys, time
        import urllib2
        import json
        import framework
        from moniItems import mon
        from daemon import Daemon

        class MyDaemon(Daemon):
            def run(self):
                print &apos;start&apos;
                framework.startTh()
                print &apos;stop2&apos;

        if __name__ == &quot;__main__&quot;:
            daemon = MyDaemon()
            if len(sys.argv) == 2:
                if &apos;start&apos; == sys.argv[1]:
                    daemon.start()
                elif &apos;stop&apos; == sys.argv[1]:
                    daemon.stop()
                elif &apos;restart&apos; == sys.argv[1]:
                    daemon.restart()
                else:
                    print &quot;Unknown command&quot;
                    sys.exit(2)
                sys.exit(0)
            else:
                print &quot;usage: %s start|stop|restart&quot; % sys.argv[0]
                sys.exit(2)

psutil          [获取系统信息]

    pip install psutil                     # 安装

    import psutil
    dir(psutil)
    psutil.boot_time()                     # 开机时间
    psutil.virtual_memory()                # 内存详细信息
    psutil.virtual_memory().total          # 内存总大小
    psutil.disk_partitions()               # 获取磁盘信息
    psutil.disk_io_counters()              # 磁盘IO信息
    psutil.net_io_counters()               # 获取网络IO信息

    psutil.pids()                          # 返回所有进程PID
    psutil.Process(PID)                    # 获取进程信息
    psutil.Process(PID).name()             # 指定进程的进程名
    psutil.Process(PID).exe()              # 进程的路径
    psutil.Process(PID).cwd()              # 进程工作路径
    psutil.Process(PID).status()           # 进程状态
    psutil.Process(PID).create_time()      # 进程创建时间
    psutil.Process(PID).memory_percent()   # 进程内存使用率
    psutil.Process(PID).io_counters()      # 进程IO信息
    psutil.Process(PID).num_threads()      # 进程线程数

ldap            [统一认证]
    yum install openldap  openldap-clients openldap-devel openssl-devel setuptools==30.1.0
    sudo pip uninstall ldap ldap3
    pip install python-ldap
    import ldap
    con = ldap.initialize(&quot;ldap://10.10.10.156:389&quot;)
    con.simple_bind_s(&quot;cn=admin,ou=People,dc=gt,dc=com&quot;, &quot;pwd&quot;)
    res = con.search_s(&quot;dc=gt,dc=com&quot;, ldap.SCOPE_SUBTREE, &apos;(uid=*)&apos;, [&apos;*&apos;, &apos;+&apos;], 0)

watchdog        [监视文件实时写入]

    https://pypi.python.org/pypi/watchdog
    pip install watchdog

    import sys
    import time
    import logging
    from watchdog.observers import Observer
    from watchdog.events import LoggingEventHandler

    if __name__ == &quot;__main__&quot;:
        logging.basicConfig(level=logging.INFO,
                            format=&apos;%(asctime)s - %(message)s&apos;,
                            datefmt=&apos;%Y-%m-%d %H:%M:%S&apos;)
        path = sys.argv[1] if len(sys.argv) &gt; 1 else &apos;.&apos;
        event_handler = LoggingEventHandler()
        observer = Observer()
        observer.schedule(event_handler, path, recursive=True)
        observer.start()
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            observer.stop()
        observer.join()

yaml            [标记语言]

    pip  install  pyyaml

    import yaml

    a = yaml.load(&quot;&quot;&quot;
    name: Vorlin Laruknuzum
    sex: Male
    class: Priest
    title: Acolyte
    hp: [32, 71]
    sp: [1, 13]
    gold: 423
    inventory:
    - a Holy Book of Prayers (Words of Wisdom)
    - an Azure Potion of Cure Light Wounds
    - a Silver Wand of Wonder
    &quot;&quot;&quot;)

    print a[&apos;inventory&apos;][1]     # 字典
    print yaml.dump(a)          # 把字典生成yaml文件
    yaml.load_all               # 生成迭代器

    print yaml.dump({&apos;name&apos;: &quot;The Cloak &apos;Colluin&apos;&quot;, &apos;depth&apos;: 5, &apos;rarity&apos;: 45,
        &apos;weight&apos;: 10, &apos;cost&apos;: 50000, &apos;flags&apos;: [&apos;INT&apos;, &apos;WIS&apos;, &apos;SPEED&apos;, &apos;STEALTH&apos;]})

itertools       [迭代功能函数]

    import itertools
    # 全排序
    print list(itertools.permutations([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;],4))

    # 无限迭代
    ns = itertools.count(1)
    for n in ns:
        print n

    # 指定次数循环
    ns = itertools.repeat(&apos;A&apos;, 10)
    for n in ns:
        print n</code></pre><p>3 socket</p>
<pre><code>socket.gethostname()     # 获取主机名
from socket import *     # 避免 socket.socket()
s=socket()
s.bind()                 # 绑定地址到套接字
s.listen()               # 开始TCP监听
s.accept()               # 被动接受TCP客户端连接，等待连接的到来
s.connect()              # 主动初始化TCP服务器连接
s.connect_ex()           # connect()函数的扩展版本，出错时返回出错码，而不是跑出异常
s.recv()                 # 接收TCP数据
s.send()                 # 发送TCP数据
s.sendall()              # 完整发送TCP数据
s.recvfrom()             # 接收UDP数据
s.sendto()               # 发送UDP数据
s.getpeername()          # 连接到当前套接字的远端的地址(TCP连接)
s.getsockname()          # 当前套接字的地址
s.getsockopt()           # 返回指定套接字的参数
s.setsockopt()           # 设置指定套接字的参数
s.close()                # 关闭套接字
s.setblocking()          # 设置套接字的阻塞与非阻塞模式
s.settimeout()           # 设置阻塞套接字操作的超时时间
s.gettimeout()           # 得到阻塞套接字操作的超时时间
s.makefile()             # 创建一个与该套接字关联的文件对象
s.fileno()               # 套接字获取对应的文件描述符fd

socket.AF_UNIX           # 只能够用于单一的Unix系统进程间通信
socket.AF_INET           # 服务器之间网络通信
socket.AF_INET6          # IPv6

socket.SOCK_STREAM       # 流式socket , for TCP
socket.SOCK_DGRAM        # 数据报式socket , for UDP
socket.SOCK_RAW          # 原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。

socket.SOCK_RDM          # 是一种可靠的UDP形式，即保证交付数据报但不保证顺序。SOCK_RAM用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，如发送ICMP报文。SOCK_RAM通常仅限于高级用户或管理员运行的程序使用。

socket.SOCK_SEQPACKET    # 可靠的连续数据包服务

socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)   # 关闭server后马上释放端口,避免被TIME_WAIT占用

select          [IO多路复用的机制]

    # select每次遍历都需要把fd集合从用户态拷贝到内核态,开销较大,受系统限制最大1024
    select.select(rlist, wlist, xlist[, timeout])
    # poll和select很像 通过一个pollfd数组向内核传递需要关注的事件,没有描述符1024限制
    select.poll()
    # 创建epoll句柄,注册监听事件,通过回调函数等待事件产生,不做主动扫描,整个过程对fd只做一次拷贝.打开最大文件数后,不受限制,1GB内存大约是10万链接
    select.epoll([sizehint=-1])

    select.epoll

        EPOLLIN                # 监听可读事件
        EPOLLET                # 高速边缘触发模式,即触发后不会再次触发直到新接收数据
        EPOLLOUT               # 监听写事件

        epoll.poll([timeout=-1[, maxevents=-1]]) # 等待事件,未指定超时时间[毫秒]则为一直阻塞等待
        epoll.register(fd,EPOLLIN)               # 向epoll句柄中注册,新来socket链接,监听可读事件
        epoll.modify(fd, EPOLLET | EPOLLOUT)     # 改变监听事件为边缘触发,监听写事件
        epoll.fileno()                           # 通过链接对象得到fd
        epoll.unregister(fd)                     # 取消fd监听事件

SocketServer

    #!/usr/bin/python
    #server.py
    import SocketServer
    import os
    class MyTCP(SocketServer.BaseRequestHandler):
        def handle(self):
            # 应该已经封装好了 不需要这层while了 可能会引起大量 close_wait
            while True:
                self.data=self.request.recv(1024).strip()
                if self.data == &apos;quit&apos; or not self.data:break

                cmd=os.popen(self.data).read()
                if cmd == &apos;&apos;:cmd= self.data + &apos;: Command not found&apos;
                self.request.sendall(cmd)
    if __name__ == &apos;__main__&apos;:
        HOST,PORT = &apos;10.0.0.119&apos;,50007
        server = SocketServer.ThreadingTCPServer((HOST,PORT),MyTCP)
        server.serve_forever()

SocketClient

    #!/usr/bin/python
    #client.py
    import socket

    HOST=&apos;10.0.0.119&apos;
    PORT=50007
    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect((HOST,PORT))

    while True:
        while True:
            cmd=raw_input(&apos;CMD:&apos;).strip()
            if cmd != &apos;&apos;:break
        s.sendall(cmd)
        data=s.recv(1024).split(&apos;\n&apos;)
        print &apos;cmd:&apos;
        for line in data:print line
    s.close()

ftp

    ftpserver

        #!/usr/bin/python
        #ftpserver.py

        import SocketServer
        import os
        import cPickle
        import md5
        from time import sleep

        def filer(file1):
            try:
                f = file(file1,&apos;rb&apos;)
                return cPickle.load(f)
            except IOError:
                return {}
            except EOFError:
                return {}
            f.close()

        def filew(file1,content):
            f = file(file1,&apos;wb&apos;)
            cPickle.dump(content,f)
            f.close()

        class MyTCP(SocketServer.BaseRequestHandler):
            def handle(self):
                i = 0
                while i&lt;3:
                    user=self.request.recv(1024).strip()
                    userinfo=filer(&apos;user.pkl&apos;)
                    if userinfo.has_key(user.split()[0]):
                        if md5.new(user.split()[1]).hexdigest() == userinfo[user.split()[0]]:
                            results=&apos;login successful&apos;
                            self.request.sendall(results)
                            login=&apos;successful&apos;
                            break
                        else:
                            i = i + 1
                            results=&apos;Error:password not correct&apos;
                            self.request.sendall(results)
                            continue
                    else:
                        i = i + 1
                        results=&apos;Error:password not correct&apos;
                        self.request.sendall(results)
                        continue
                    break
                else:
                    results = &apos;Error:Wrong password too many times&apos;
                    self.request.sendall(results)
                    login=&apos;failure&apos;
                home_path = os.popen(&apos;pwd&apos;).read().strip() + &apos;/&apos; + user.split()[0]
                current_path = &apos;/&apos;
                print home_path
                while True:
                    if login == &apos;failure&apos;:
                        break
                    print &apos;home_path:%s=current_path:%s&apos; %(home_path,current_path)
                    cmd=self.request.recv(1024).strip()
                    print cmd
                    if cmd == &apos;quit&apos;:
                        break
                    elif cmd == &apos;dir&apos;:
                        list=os.listdir(&apos;%s%s&apos; %(home_path,current_path))
                        if list:
                            dirlist,filelist = &apos;&apos;,&apos;&apos;
                            for i in list:
                                if os.path.isdir(&apos;%s%s%s&apos; %(home_path,current_path,i)):
                                    dirlist = dirlist + &apos;\033[32m&apos; + i + &apos;\033[m\t&apos;
                                else:
                                    filelist = filelist + i + &apos;\t&apos;
                            results = dirlist + filelist
                        else:
                            results = &apos;\033[31mnot find\033[m&apos;
                        self.request.sendall(results)
                    elif cmd == &apos;pdir&apos;:
                        self.request.sendall(current_path)
                    elif cmd.split()[0] == &apos;mdir&apos;:
                        if cmd.split()[1].isalnum():
                            tmppath=&apos;%s%s%s&apos; %(home_path,current_path,cmd.split()[1])
                            os.makedirs(tmppath)
                            self.request.sendall(&apos;\033[32mcreating successful\033[m&apos;)
                        else:
                            self.request.sendall(&apos;\033[31mcreate failure\033[m&apos;)
                    elif cmd.split()[0] == &apos;cdir&apos;:
                        if cmd.split()[1] == &apos;/&apos;:
                            tmppath=&apos;%s%s&apos; %(home_path,cmd.split()[1])
                            if os.path.isdir(tmppath):
                                current_path = cmd.split()[1]
                                self.request.sendall(current_path)
                            else:
                                self.request.sendall(&apos;\033[31mnot_directory\033[m&apos;)
                        elif cmd.split()[1].startswith(&apos;/&apos;):
                            tmppath=&apos;%s%s&apos; %(home_path,cmd.split()[1])
                            if os.path.isdir(tmppath):
                                current_path = cmd.split()[1] + &apos;/&apos;
                                self.request.sendall(current_path)
                            else:
                                self.request.sendall(&apos;\033[31mnot_directory\033[m&apos;)
                        else:
                            tmppath=&apos;%s%s%s&apos; %(home_path,current_path,cmd.split()[1])
                            if os.path.isdir(tmppath):
                                current_path = current_path + cmd.split()[1] + &apos;/&apos;
                                self.request.sendall(current_path)
                            else:
                                self.request.sendall(&apos;\033[31mnot_directory\033[m&apos;)
                    elif cmd.split()[0] == &apos;get&apos;:
                        if os.path.isfile(&apos;%s%s%s&apos; %(home_path,current_path,cmd.split()[1])):
                            f = file(&apos;%s%s%s&apos; %(home_path,current_path,cmd.split()[1]),&apos;rb&apos;)
                            self.request.sendall(&apos;ready_file&apos;)
                            sleep(0.5)
                            self.request.send(f.read())
                            f.close()
                            sleep(0.5)
                        elif os.path.isdir(&apos;%s%s%s&apos; %(home_path,current_path,cmd.split()[1])):
                            self.request.sendall(&apos;ready_dir&apos;)
                            sleep(0.5)
                            for dirpath in os.walk(&apos;%s%s%s&apos; %(home_path,current_path,cmd.split()[1])):
                                dir=dirpath[0].replace(&apos;%s%s&apos; %(home_path,current_path),&apos;&apos;,1)
                                self.request.sendall(dir)
                                sleep(0.5)
                                for filename in dirpath[2]:
                                    self.request.sendall(filename)
                                    sleep(0.5)
                                    f = file(&apos;%s/%s&apos; %(dirpath[0],filename),&apos;rb&apos;)
                                    self.request.send(f.read())
                                    f.close()
                                    sleep(0.5)
                                    self.request.sendall(&apos;file_get_done&apos;)
                                    sleep(0.5)
                                else:
                                    self.request.sendall(&apos;dir_get_done&apos;)
                                sleep(0.5)
                        else:
                            self.request.sendall(&apos;get_failure&apos;)
                            continue
                        self.request.sendall(&apos;get_done&apos;)

                    elif cmd.split()[0] == &apos;send&apos;:
                        if os.path.exists(&apos;%s%s%s&apos; %(home_path,current_path,cmd.split()[1])):
                            self.request.sendall(&apos;existing&apos;)
                            action=self.request.recv(1024)
                            if action == &apos;cancel&apos;:
                                continue
                        self.request.sendall(&apos;ready&apos;)
                        msg=self.request.recv(1024)
                        if msg == &apos;ready_file&apos;:
                            f = file(&apos;%s%s%s&apos; %(home_path,current_path,cmd.split()[1]),&apos;wb&apos;)
                            while True:
                                data=self.request.recv(1024)
                                if data == &apos;file_send_done&apos;:break
                                f.write(data)
                            f.close()

                        elif msg == &apos;ready_dir&apos;:
                            os.system(&apos;mkdir -p %s%s%s&apos; %(home_path,current_path,cmd.split()[1]))
                            while True:
                                dir=self.request.recv(1024)
                                if dir == &apos;get_done&apos;:break
                                os.system(&apos;mkdir -p %s%s%s&apos; %(home_path,current_path,dir))
                                while True:
                                    filename=self.request.recv(1024)
                                    if filename == &apos;dir_send_done&apos;:break
                                    f = file(&apos;%s%s%s/%s&apos; %(home_path,current_path,dir,filename),&apos;wb&apos;)
                                    while True:
                                        data=self.request.recv(1024)
                                        if data == &apos;file_send_done&apos;:break
                                        f.write(data)
                                    f.close()
                                    self.request.sendall(&apos;%s/%s\t\033[32mfile_done\033[m&apos; %(dir,filename))
                                self.request.sendall(&apos;%s\t\033[32mdir_done\033[m&apos; %(dir))
                        elif msg == &apos;unknown_file&apos;:
                            continue

                    else:
                        results = cmd.split()[0] + &apos;: Command not found&apos;
                        self.request.sendall(results)

        if __name__ == &apos;__main__&apos;:
            HOST,PORT = &apos;10.152.14.85&apos;,50007
            server = SocketServer.ThreadingTCPServer((HOST,PORT),MyTCP)
            server.serve_forever()

    ftpmanage

        #!/usr/bin/python
        #manage_ftp.py
        import cPickle
        import sys
        import md5
        import os
        import getpass

        def filer(file1):
            try:
                f = file(file1,&apos;rb&apos;)
                return cPickle.load(f)
            except IOError:
                return {}
            except EOFError:
                return {}
            f.close()

        def filew(file1,content):
            f = file(file1,&apos;wb&apos;)
            cPickle.dump(content,f)
            f.close()

        while True:
            print &apos;&apos;&apos;
            1.add user
            2.del user
            3.change password
            4.query user
            0.exit
            &apos;&apos;&apos;
            i = raw_input(&apos;:&apos;).strip()
            userinfo=filer(&apos;user.pkl&apos;)
            if i == &apos;&apos;:
                continue
            elif i == &apos;1&apos;:
                while True:
                    user=raw_input(&apos;user name:&apos;).strip()
                    if user.isalnum():
                        i = 0
                        while i&lt;3:
                            passwd=getpass.getpass(&apos;passwd:&apos;).strip()
                            if passwd == &apos;&apos;:
                                continue
                            else:
                                passwd1=getpass.getpass(&apos;Confirm password:&apos;).strip()
                                if passwd == passwd1:
                                    mpasswd = md5.new(passwd).hexdigest()
                                    userinfo[user] = mpasswd
                                    os.system(&apos;mkdir -p %s&apos; %user)
                                    print &apos;%s creating successful &apos; %user
                                    break
                                else:
                                    print &quot;Passwords don&apos;t match &quot;
                                    i = i + 1
                                    continue
                        else:
                            print &apos;Too many wrong&apos;
                            continue
                        break
                    else:
                        print &apos;user not legal&apos;
                        continue
            elif i == &apos;2&apos;:
                user=raw_input(&apos;user name:&apos;).strip()
                if userinfo.has_key(user):
                    del userinfo[user]
                    print &apos;Delete users successfully&apos;
                else:
                    print &apos;user not exist&apos;
                    continue
            elif i == &apos;3&apos;:
                user=raw_input(&apos;user name:&apos;).strip()
                if userinfo.has_key(user):
                    i = 0
                    while i&lt;3:
                        passwd=getpass.getpass(&apos;passwd:&apos;).strip()
                        if passwd == &apos;&apos;:
                            continue
                        else:
                            passwd1=getpass.getpass(&apos;Confirm password:&apos;).strip()
                            if passwd == passwd1:
                                mpasswd = md5.new(passwd).hexdigest()
                                userinfo[user] = mpasswd
                                print &apos;%s password is changed&apos; %user
                                break
                            else:
                                print &quot;Passwords don&apos;t match &quot;
                                i = i + 1
                                continue
                    else:
                        print &apos;Too many wrong&apos;
                        continue
                else:
                    print &apos;user not exist&apos;
                    continue
            elif i == &apos;4&apos;:
                print userinfo.keys()
            elif i == &apos;0&apos;:
                sys.exit()
            else:
                print &apos;select error&apos;
                continue
            filew(&apos;user.pkl&apos;,content=userinfo)

    ftpclient

        #!/usr/bin/python
        #ftpclient.py

        import socket
        import os
        import getpass
        from time import sleep

        HOST=&apos;10.152.14.85&apos;
        PORT=50007
        s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        s.connect((HOST,PORT))

        while True:
            user = raw_input(&apos;user:&apos;).strip()
            if user.isalnum():
                while True:
                    passwd = getpass.getpass(&apos;passwd:&apos;).strip()
                    s.sendall(user + &apos; &apos; + passwd)
                    servercmd=s.recv(1024)
                    if servercmd == &apos;login successful&apos;:
                        print &apos;\033[32m%s\033[m&apos; %servercmd
                        break
                    else:
                        print servercmd

                while True:
                    cmd=raw_input(&apos;FTP&gt;&apos;).strip()
                    if cmd == &apos;&apos;:
                        continue
                    if cmd.split()[0] == &apos;get&apos;:
                        if cmd == &apos;get&apos;:continue
                        for i in cmd.split()[1:]:
                            if os.path.exists(i):
                                confirm = raw_input(&quot;\033[31mPlease confirm whether the cover %s(Y/N):\033[m&quot; %(i)).upper().startswith(&apos;Y&apos;)
                                if not confirm:
                                    print &apos;%s cancel&apos; %i
                                    continue
                            s.sendall(&apos;get &apos; + i)
                            servercmd=s.recv(1024)
                            if servercmd == &apos;inexistence&apos;:
                                print &apos;%s \t\033[32minexistence\033[m&apos; %i
                                continue
                            elif servercmd == &apos;ready_file&apos;:
                                f = file(i,&apos;wb&apos;)
                                while True:
                                    data=s.recv(1024)
                                    if data == &apos;get_done&apos;:break
                                    f.write(data)
                                f.close()
                                print &apos;%s \t\033[32mfile_done\033[m&apos; %(i)
                            elif servercmd == &apos;ready_dir&apos;:
                                try:
                                    os.makedirs(i)
                                except:
                                    pass
                                while True:
                                    serverdir=s.recv(1024)
                                    if serverdir == &apos;get_done&apos;:break
                                    os.system(&apos;mkdir -p %s&apos; %serverdir)
                                    print &apos;%s \t\033[32mdir_done\033[m&apos; %(serverdir)
                                    while True:
                                        serverfile=s.recv(1024)
                                        if serverfile == &apos;dir_get_done&apos;:break
                                        f = file(&apos;%s/%s&apos; %(serverdir,serverfile),&apos;wb&apos;)
                                        while True:
                                            data=s.recv(1024)
                                            if data == &apos;file_get_done&apos;:break
                                            f.write(data)
                                        f.close()
                                        print &apos;%s/%s \t\033[32mfile_done\033[m&apos; %(serverdir,serverfile)

                    elif cmd.split()[0] == &apos;send&apos;:

                        if cmd == &apos;send&apos;:continue
                        for i in cmd.split()[1:]:
                            if not os.path.exists(i):
                                print &apos;%s\t\033[31minexistence\033[m&apos; %i
                                continue

                            s.sendall(&apos;send &apos; + i)
                            servercmd=s.recv(1024)
                            if servercmd == &apos;existing&apos;:
                                confirm = raw_input(&quot;\033[31mPlease confirm whether the cover %s(Y/N):\033[m&quot; %(i)).upper().startswith(&apos;Y&apos;)
                                if confirm:
                                    s.sendall(&apos;cover&apos;)
                                    servercmd=s.recv(1024)
                                else:
                                    s.sendall(&apos;cancel&apos;)
                                    print &apos;%s\tcancel&apos; %i
                                    continue

                            if os.path.isfile(i):
                                s.sendall(&apos;ready_file&apos;)
                                sleep(0.5)
                                f = file(i,&apos;rb&apos;)
                                s.send(f.read())
                                sleep(0.5)
                                s.sendall(&apos;file_send_done&apos;)
                                print &apos;%s\t\033[32mfile done\033[m&apos; %(cmd.split()[1])
                                f.close()
                            elif os.path.isdir(i):
                                s.sendall(&apos;ready_dir&apos;)
                                sleep(0.5)
                                for dirpath in os.walk(i):
                                    dir=dirpath[0].replace(&apos;%s/&apos; %os.popen(&apos;pwd&apos;).read().strip(),&apos;&apos;,1)
                                    s.sendall(dir)
                                    sleep(0.5)
                                    for filename in dirpath[2]:
                                        s.sendall(filename)
                                        sleep(0.5)
                                        f = file(&apos;%s/%s&apos; %(dirpath[0],filename),&apos;rb&apos;)
                                        s.send(f.read())
                                        f.close()
                                        sleep(0.5)
                                        s.sendall(&apos;file_send_done&apos;)
                                        msg=s.recv(1024)
                                        print msg

                                    else:
                                        s.sendall(&apos;dir_send_done&apos;)
                                        msg=s.recv(1024)
                                        print msg

                            else:
                                s.sendall(&apos;unknown_file&apos;)
                                print &apos;%s\t\033[31munknown type\033[m&apos; %i
                                continue
                            sleep(0.5)
                            s.sendall(&apos;get_done&apos;)

                    elif cmd.split()[0] == &apos;cdir&apos;:
                        if cmd == &apos;cdir&apos;:continue
                        s.sendall(cmd)
                        data=s.recv(1024)
                        print data
                        continue
                    elif cmd == &apos;ls&apos;:
                        list=os.popen(cmd).read().strip().split(&apos;\n&apos;)
                        if list:
                            dirlist,filelist = &apos;&apos;,&apos;&apos;
                            for i in list:
                                if os.path.isdir(i):
                                    dirlist = dirlist + &apos;\033[32m&apos; + i + &apos;\033[m\t&apos;
                                else:
                                    filelist = filelist + i + &apos;\t&apos;
                            results = dirlist + filelist
                        else:
                            results = &apos;\033[31mnot find\033[m&apos;
                        print results
                        continue
                    elif cmd == &apos;pwd&apos;:
                        os.system(cmd)
                    elif cmd.split()[0] == &apos;cd&apos;:
                        try:
                            os.chdir(cmd.split()[1])
                        except:
                            print &apos;\033[31mcd failure\033[m&apos;
                    elif cmd == &apos;dir&apos;:
                        s.sendall(cmd)
                        data=s.recv(1024)
                        print data
                        continue
                    elif cmd == &apos;pdir&apos;:
                        s.sendall(cmd)
                        data=s.recv(1024)
                        print data
                        continue
                    elif cmd.split()[0] == &apos;mdir&apos;:
                        if cmd == &apos;mdir&apos;:continue
                        s.sendall(cmd)
                        data=s.recv(1024)
                        print data
                        continue
                    elif cmd.split()[0] == &apos;help&apos;:
                        print &apos;&apos;&apos;
            get [file] [dir]
            send [file] [dir]

            dir
            mdir
            cdir
            pdir

            pwd
            md
            cd
            ls

            help
            quit
            &apos;&apos;&apos;
                        continue
                    elif cmd == &apos;quit&apos;:
                        break
                    else:
                        print &apos;\033[31m%s: Command not found,Please see the &quot;help&quot;\033[m&apos; %cmd
            else:
                continue
            break
        s.close()

扫描主机开放端口
    #!/usr/bin/env python

    import socket

    def check_server(address,port):
        s=socket.socket()
        try:
            s.connect((address,port))
            return True
        except socket.error,e:
            return False

    if __name__==&apos;__main__&apos;:
        from optparse import OptionParser
        parser=OptionParser()
        parser.add_option(&quot;-a&quot;,&quot;--address&quot;,dest=&quot;address&quot;,default=&apos;localhost&apos;,help=&quot;Address for server&quot;,metavar=&quot;ADDRESS&quot;)
        parser.add_option(&quot;-s&quot;,&quot;--start&quot;,dest=&quot;start_port&quot;,type=&quot;int&quot;,default=1,help=&quot;start port&quot;,metavar=&quot;SPORT&quot;)
        parser.add_option(&quot;-e&quot;,&quot;--end&quot;,dest=&quot;end_port&quot;,type=&quot;int&quot;,default=1,help=&quot;end port&quot;,metavar=&quot;EPORT&quot;)
        (options,args)=parser.parse_args()
        print &apos;options: %s, args: %s&apos; % (options, args)
        port=options.start_port
        while(port&lt;=options.end_port):
            check = check_server(options.address, port)
            if (check):
                print &apos;Port  %s is on&apos; % port
            port=port+1

zmq [网络通讯库]

    # https://github.com/zeromq/pyzmq
    # pip install pyzmq
    # ZMQ是一个开源的、跨语言的、非常简洁的、非常高性能、非常灵活的网络通讯库

    服务端程序
        import zmq
        context = zmq.Context()
        socket = context.socket(zmq.REP)
        socket.bind(&quot;tcp://127.0.0.1:1234&quot;)   # 提供传输协议  INPROC  IPC  MULTICAST  TCP

        while True :
            msg = socket.recv()
            socket.send(msg)

    客户端端程序
        import zmq
        context = zmq.Context()
        socket = context.socket(zmq.REQ)
        socket.connect(&quot;tcp://127.0.0.1:1234&quot;)
        # socket.connect(&quot;tcp://127.0.0.1:6000&quot;)    # 设置2个可以均衡负载请求到2个监听的server
        msg_send = &quot;xxx&quot;socket.send(msg_send)
        print &quot;Send:&quot;, msg_send
        msg_recv = socket.recv()
        print &quot;Receive:&quot;, msg_recv

epoll
    https://docs.python.org/2/library/select.html    # python官网

    epoll短链接server
        # 原文  http://my.oschina.net/moooofly/blog/147297
        # 此代码还有改进地方，在接收数据和发送数据都是阻塞死循环处理，必须等待全部接收完毕才会继续操作
        server端代码：

            #!/usr/bin/python
            #-*- coding:utf-8 -*-

            import socket, logging
            import select, errno

            logger = logging.getLogger(&quot;network-server&quot;)

            def InitLog():
                logger.setLevel(logging.DEBUG)

                fh = logging.FileHandler(&quot;network-server.log&quot;)
                fh.setLevel(logging.DEBUG)
                ch = logging.StreamHandler()
                ch.setLevel(logging.ERROR)

                formatter = logging.Formatter(&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;)
                ch.setFormatter(formatter)
                fh.setFormatter(formatter)

                logger.addHandler(fh)
                logger.addHandler(ch)

            if __name__ == &quot;__main__&quot;:
                InitLog()

                try:
                    # 创建 TCP socket 作为监听 socket
                    listen_fd = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
                except socket.error, msg:
                    logger.error(&quot;create socket failed&quot;)

                try:
                    # 设置 SO_REUSEADDR 选项
                    listen_fd.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                except socket.error, msg:
                    logger.error(&quot;setsocketopt SO_REUSEADDR failed&quot;)

                try:
                    # 进行 bind -- 此处未指定 ip 地址，即 bind 了全部网卡 ip 上
                    listen_fd.bind((&apos;&apos;, 2003))
                except socket.error, msg:
                    logger.error(&quot;bind failed&quot;)

                try:
                    # 设置 listen 的 backlog 数
                    listen_fd.listen(10)
                except socket.error, msg:
                    logger.error(msg)

                try:
                    # 创建 epoll 句柄
                    epoll_fd = select.epoll()
                    # 向 epoll 句柄中注册 监听 socket 的 可读 事件
                    epoll_fd.register(listen_fd.fileno(), select.EPOLLIN)
                except select.error, msg:
                    logger.error(msg)

                connections = {}
                addresses = {}
                datalist = {}
                while True:
                    # epoll 进行 fd 扫描的地方 -- 未指定超时时间则为阻塞等待
                    epoll_list = epoll_fd.poll()

                    for fd, events in epoll_list:
                        # 若为监听 fd 被激活
                        if fd == listen_fd.fileno():
                            # 进行 accept -- 获得连接上来 client 的 ip 和 port，以及 socket 句柄
                            conn, addr = listen_fd.accept()
                            logger.debug(&quot;accept connection from %s, %d, fd = %d&quot; % (addr[0], addr[1], conn.fileno()))
                            # 将连接 socket 设置为 非阻塞
                            conn.setblocking(0)
                            # 向 epoll 句柄中注册 连接 socket 的 可读 事件
                            epoll_fd.register(conn.fileno(), select.EPOLLIN | select.EPOLLET)
                            # 将 conn 和 addr 信息分别保存起来
                            connections[conn.fileno()] = conn
                            addresses[conn.fileno()] = addr
                        elif select.EPOLLIN &amp; events:
                            # 有 可读 事件激活
                            datas = &apos;&apos;
                            while True:
                                try:
                                    # 从激活 fd 上 recv 10 字节数据
                                    data = connections[fd].recv(10)
                                    # 若当前没有接收到数据，并且之前的累计数据也没有
                                    if not data and not datas:
                                        # 从 epoll 句柄中移除该 连接 fd
                                        epoll_fd.unregister(fd)
                                        # server 侧主动关闭该 连接 fd
                                        connections[fd].close()
                                        logger.debug(&quot;%s, %d closed&quot; % (addresses[fd][0], addresses[fd][1]))
                                        break
                                    else:
                                        # 将接收到的数据拼接保存在 datas 中
                                        datas += data
                                except socket.error, msg:
                                    # 在 非阻塞 socket 上进行 recv 需要处理 读穿 的情况
                                    # 这里实际上是利用 读穿 出 异常 的方式跳到这里进行后续处理
                                    if msg.errno == errno.EAGAIN:
                                        logger.debug(&quot;%s receive %s&quot; % (fd, datas))
                                        # 将已接收数据保存起来
                                        datalist[fd] = datas
                                        # 更新 epoll 句柄中连接d 注册事件为 可写
                                        epoll_fd.modify(fd, select.EPOLLET | select.EPOLLOUT)
                                        break
                                    else:
                                        # 出错处理
                                        epoll_fd.unregister(fd)
                                        connections[fd].close()
                                        logger.error(msg)
                                        break
                        elif select.EPOLLHUP &amp; events:
                            # 有 HUP 事件激活
                            epoll_fd.unregister(fd)
                            connections[fd].close()
                            logger.debug(&quot;%s, %d closed&quot; % (addresses[fd][0], addresses[fd][1]))
                        elif select.EPOLLOUT &amp; events:
                            # 有 可写 事件激活
                            sendLen = 0
                            # 通过 while 循环确保将 buf 中的数据全部发送出去
                            while True:
                                # 将之前收到的数据发回 client -- 通过 sendLen 来控制发送位置
                                sendLen += connections[fd].send(datalist[fd][sendLen:])
                                # 在全部发送完毕后退出 while 循环
                                if sendLen == len(datalist[fd]):
                                    break
                            # 更新 epoll 句柄中连接 fd 注册事件为 可读
                            epoll_fd.modify(fd, select.EPOLLIN | select.EPOLLET)
                        else:
                            # 其他 epoll 事件不进行处理
                            continue

        client 端代码

            import socket
            import time
            import logging

            logger = logging.getLogger(&quot;network-client&quot;)
            logger.setLevel(logging.DEBUG)

            fh = logging.FileHandler(&quot;network-client.log&quot;)
            fh.setLevel(logging.DEBUG)
            ch = logging.StreamHandler()
            ch.setLevel(logging.ERROR)

            formatter = logging.Formatter(&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;)
            ch.setFormatter(formatter)
            fh.setFormatter(formatter)

            logger.addHandler(fh)
            logger.addHandler(ch)

            if __name__ == &quot;__main__&quot;:
                try:
                    connFd = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
                except socket.error, msg:
                    logger.error(msg)

                try:
                    connFd.connect((&quot;127.0.0.1&quot;, 2003))
                    logger.debug(&quot;connect to network server success&quot;)
                except socket.error,msg:
                    logger.error(msg)

                for i in range(1, 11):
                    data = &quot;The Number is %d&quot; % i
                    if connFd.send(data) != len(data):
                        logger.error(&quot;send data to network server failed&quot;)
                        break
                    readData = connFd.recv(1024)
                    print readData
                    time.sleep(1)

                connFd.close()</code></pre><p>4 mysql</p>
<pre><code># yum install mysql-devel python-tools gcc openssl-devel
pip install MySQL-python
# yum install python-MySQLdb MySQL-python

help(MySQLdb.connections.Connection)      # 查看链接参数

conn=MySQLdb.connect(host=&apos;localhost&apos;,user=&apos;root&apos;,passwd=&apos;123456&apos;,db=&apos;fortress&apos;,port=3306)    # 定义连接
#conn=MySQLdb.connect(unix_socket=&apos;/var/run/mysqld/mysqld.sock&apos;,user=&apos;root&apos;,passwd=&apos;123456&apos;)   # 使用socket文件链接
conn.autocommit(True)                                        # 自动提交
cur=conn.cursor()                                            # 定义游标
conn.select_db(&apos;fortress&apos;)                                   # 选择数据库
sqlcmd = &apos;insert into user(name,age) value(%s,%s)&apos;           # 定义sql命令
cur.executemany(sqlcmd,[(&apos;aa&apos;,1),(&apos;bb&apos;,2),(&apos;cc&apos;,3)])         # 插入多条值
cur.execute(&apos;delete from user where id=20&apos;)                  # 删除一条记录
cur.execute(&quot;update user set name=&apos;a&apos; where id=20&quot;)          # 更细数据
sqlresult = cur.fetchall()                                   # 接收全部返回结果
conn.commit()                                                # 提交
cur.close()                                                  # 关闭游标
conn.close()                                                 # 关闭连接

import MySQLdb
def mydb(dbcmdlist):
    try:
        conn=MySQLdb.connect(host=&apos;localhost&apos;,user=&apos;root&apos;,passwd=&apos;123456&apos;,db=&apos;fortress&apos;,port=3306)
        conn.autocommit(True)
        cur=conn.cursor()

        cur.execute(&apos;create database if not exists fortress;&apos;)  # 创建数据库
        conn.select_db(&apos;fortress&apos;)                              # 选择数据库
        cur.execute(&apos;drop table if exists log;&apos;)                # 删除表
        cur.execute(&apos;CREATE TABLE log ( id BIGINT(20) NOT NULL AUTO_INCREMENT, loginuser VARCHAR(50) DEFAULT NULL, remoteip VARCHAR(50) DEFAULT NULL, PRIMARY KEY (id) );&apos;)  # 创建表

        result=[]
        for dbcmd in dbcmdlist:
            cur.execute(dbcmd)           # 执行sql
            sqlresult = cur.fetchall()   # 接收全部返回结果
            result.append(sqlresult)
        conn.commit()                    # 提交
        cur.close()
        conn.close()
        return result
    except MySQLdb.Error,e:
        print &apos;mysql error msg: &apos;,e
sqlcmd=[]
sqlcmd.append(&quot;insert into log (loginuser,remoteip)values(&apos;%s&apos;,&apos;%s&apos;);&quot; %(loginuser,remoteip))
mydb(sqlcmd)

sqlcmd=[]
sqlcmd.append(&quot;select * from log;&quot;)
result = mydb(sqlcmd)
for i in result[0]:
    print i



mysql链接失败重试

    import MySQLdb as mysql
    import time

    class my():
        def executeSQL(self, sql=&quot;select * from `serverinfo` limit 1;&quot;):
            while True:
                try:
                    self.conn.ping()
                    break
                except Exception,e:
                    print(&apos;warning: mysql test ping fail&apos;)
                    print(str(e))
                try:
                    self.conn = mysql.connect(user=&quot;opsdeploy&quot;, passwd=&quot;123456&quot;, host=&apos;172.222.50.50&apos;, port=3306, db=&quot;ops_deploy&quot;, connect_timeout=10, compress=True, charset=&quot;utf8&quot;)
                    self.cursor = self.conn.cursor()
                    break
                except Exception,e:
                    print(&quot;mysql reconnect fail ...&quot;)
                    print(str(e))
                    time.sleep(2)
            try:
                self.cursor.execute(sql)
                self.conn.commit()
                print self.cursor.fetchall()
            except Exception,e:
                print(str(e))
    m=my()
    m.executeSQL()</code></pre><p>5 处理信号</p>
<pre><code>信号的概念

    信号(signal): 进程之间通讯的方式，是一种软件中断。一个进程一旦接收到信号就会打断原来的程序执行流程来处理信号。
    发送信号一般有两种原因:
        1(被动式)  内核检测到一个系统事件.例如子进程退出会像父进程发送SIGCHLD信号.键盘按下control+c会发送SIGINT信号
        2(主动式)  通过系统调用kill来向指定进程发送信号
    操作系统规定了进程收到信号以后的默认行为，可以通过绑定信号处理函数来修改进程收到信号以后的行为，有两个信号是不可更改的 SIGTOP 和 SIGKILL
    如果一个进程收到一个SIGUSR1信号，然后执行信号绑定函数，第二个SIGUSR2信号又来了，第一个信号没有被处理完毕的话，第二个信号就会丢弃。
    进程结束信号 SIGTERM 和 SIGKILL 的区别:  SIGTERM 比较友好，进程能捕捉这个信号，根据您的需要来关闭程序。在关闭程序之前，您可以结束打开的记录文件和完成正在做的任务。在某些情况下，假如进程正在进行作业而且不能中断，那么进程可以忽略这个SIGTERM信号。

常见信号
    kill -l      # 查看linux提供的信号

    SIGHUP  1          A     # 终端挂起或者控制进程终止
    SIGINT  2          A     # 键盘终端进程(如control+c)
    SIGQUIT 3          C     # 键盘的退出键被按下
    SIGILL  4          C     # 非法指令
    SIGABRT 6          C     # 由abort(3)发出的退出指令
    SIGFPE  8          C     # 浮点异常
    SIGKILL 9          AEF   # Kill信号  立刻停止
    SIGSEGV 11         C     # 无效的内存引用
    SIGPIPE 13         A     # 管道破裂: 写一个没有读端口的管道
    SIGALRM 14         A     # 闹钟信号 由alarm(2)发出的信号
    SIGTERM 15         A     # 终止信号,可让程序安全退出 kill -15
    SIGUSR1 30,10,16   A     # 用户自定义信号1
    SIGUSR2 31,12,17   A     # 用户自定义信号2
    SIGCHLD 20,17,18   B     # 子进程结束自动向父进程发送SIGCHLD信号
    SIGCONT 19,18,25         # 进程继续（曾被停止的进程）
    SIGSTOP 17,19,23   DEF   # 终止进程
    SIGTSTP 18,20,24   D     # 控制终端（tty）上按下停止键
    SIGTTIN 21,21,26   D     # 后台进程企图从控制终端读
    SIGTTOU 22,22,27   D     # 后台进程企图从控制终端写

    缺省处理动作一项中的字母含义如下:
        A  缺省的动作是终止进程
        B  缺省的动作是忽略此信号，将该信号丢弃，不做处理
        C  缺省的动作是终止进程并进行内核映像转储(dump core),内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。
        D  缺省的动作是停止进程，进入停止状况以后还能重新进行下去，一般是在调试的过程中（例如ptrace系统调用）
        E  信号不能被捕获
        F  信号不能被忽略

Python提供的信号
    import signal
    dir(signal)
    [&apos;NSIG&apos;, &apos;SIGABRT&apos;, &apos;SIGALRM&apos;, &apos;SIGBUS&apos;, &apos;SIGCHLD&apos;, &apos;SIGCLD&apos;, &apos;SIGCONT&apos;, &apos;SIGFPE&apos;, &apos;SIGHUP&apos;, &apos;SIGILL&apos;, &apos;SIGINT&apos;, &apos;SIGIO&apos;, &apos;SIGIOT&apos;, &apos;SIGKILL&apos;, &apos;SIGPIPE&apos;, &apos;SIGPOLL&apos;, &apos;SIGPROF&apos;, &apos;SIGPWR&apos;, &apos;SIGQUIT&apos;, &apos;SIGRTMAX&apos;, &apos;SIGRTMIN&apos;, &apos;SIGSEGV&apos;, &apos;SIGSTOP&apos;, &apos;SIGSYS&apos;, &apos;SIGTERM&apos;, &apos;SIGTRAP&apos;, &apos;SIGTSTP&apos;, &apos;SIGTTIN&apos;, &apos;SIGTTOU&apos;, &apos;SIGURG&apos;, &apos;SIGUSR1&apos;, &apos;SIGUSR2&apos;, &apos;SIGVTALRM&apos;, &apos;SIGWINCH&apos;, &apos;SIGXCPU&apos;, &apos;SIGXFSZ&apos;, &apos;SIG_DFL&apos;, &apos;SIG_IGN&apos;, &apos;__doc__&apos;, &apos;__name__&apos;, &apos;alarm&apos;, &apos;default_int_handler&apos;, &apos;getsignal&apos;, &apos;pause&apos;, &apos;signal&apos;]

绑定信号处理函数
    #encoding:utf8
    import os,signal
    from time import sleep
    def onsignal_term(a,b):
        print &apos;SIGTERM&apos;      # kill -15
    signal.signal(signal.SIGTERM,onsignal_term)     # 接收信号,执行相应函数

    def onsignal_usr1(a,b):
        print &apos;SIGUSR1&apos;      # kill -10
    signal.signal(signal.SIGUSR1,onsignal_usr1)

    while 1:
        print &apos;ID&apos;,os.getpid()
        sleep(10)

通过另外一个进程发送信号
    import os,signal
    os.kill(16175,signal.SIGTERM)    # 发送信号，16175是绑定信号处理函数的进程pid，需要自行修改
    os.kill(16175,signal.SIGUSR1)

父进程接收子进程结束发送的SIGCHLD信号
    #encoding:utf8
    import os,signal
    from time import sleep

    def onsigchld(a,b):
        print &apos;收到子进程结束信号&apos;
    signal.signal(signal.SIGCHLD,onsigchld)

    pid = os.fork()                # 创建一个子进程,复制父进程所有资源操作
    if pid == 0:                   # 通过判断子进程os.fork()是否等于0,分别同时执行父进程与子进程操作
       print &apos;我是子进程,pid是&apos;,os.getpid()
       sleep(2)
    else:
        print &apos;我是父进程,pid是&apos;,os.getpid()
        os.wait()      # 等待子进程结束

接收信号的程序，另外一端使用多线程向这个进程发送信号，会遗漏一些信号
    #encoding:utf8
    import os
    import signal
    from time import sleep
    import Queue
    QCOUNT = Queue.Queue()  # 初始化队列
    def onsigchld(a,b):
        &apos;&apos;&apos;收到信号后向队列中插入一个数字1&apos;&apos;&apos;
        print &apos;收到SIGUSR1信号&apos;
        sleep(1)
        QCOUNT.put(1)       # 向队列中写入
    signal.signal(signal.SIGUSR1,onsigchld)   # 绑定信号处理函数
    while 1:
        print &apos;我的pid是&apos;,os.getpid()
        print &apos;现在队列中元素的个数是&apos;,QCOUNT.qsize()
        sleep(2)

多线程发信号端的程序
    #encoding:utf8
    import threading
    import os
    import signal
    def sendusr1():
        print &apos;发送信号&apos;
        os.kill(17788, signal.SIGUSR1)     # 这里的进程id需要写前一个程序实际运行的pid
    WORKER = []
    for i in range(1, 7):                  # 开启6个线程
        threadinstance = threading.Thread(target = sendusr1)
        WORKER.append(threadinstance)
    for i in WORKER:
        i.start()
    for i in WORKER:
        i.join()
    print &apos;主线程完成&apos;</code></pre><p>6 缓存数据库</p>
<pre><code>python使用memcache

    easy_install python-memcached   # 安装(python2.7+)
    import memcache
    mc = memcache.Client([&apos;10.152.14.85:12000&apos;],debug=True)    # 也可以使用socket直接连接IP端口
    mc.set(&apos;name&apos;,&apos;luo&apos;,60)
    mc.get(&apos;name&apos;)
    mc.delete(&apos;name1&apos;)

    # 豆瓣的python-memcache模块，大于1M自动切割 性能是纯python的3倍+
    https://code.google.com/p/python-libmemcached/

    保存数据

        set(key,value,timeout)      # 把key映射到value，timeout指的是什么时候这个映射失效
        add(key,value,timeout)      # 仅当存储空间中不存在键相同的数据时才保存
        replace(key,value,timeout)  # 仅当存储空间中存在键相同的数据时才保存

    获取数据

        get(key)                    # 返回key所指向的value
        get_multi(key1,key2,key3)   # 可以非同步地同时取得多个键值， 比循环调用get快数十倍

python使用mongodb

    # 新版本
    http://api.mongodb.org/python/2.7.2/tutorial.html
    http://api.mongodb.org/python/current/examples/custom_type.html

    easy_install pymongo      # 安装

    import pymongo

    cl = pymongo.MongoClient(&quot;127.0.0.1&quot;, 27017)
    db = cl.ops             # 选择库
    db.name                 # 查看库名
    db.collection_names()   # 查看所有文档
    db.project              # 选择文档
    db.project.insert({&apos;name&apos;:&apos;live&apos;,&apos;group&apos;:&apos;a&apos;})
    db.project.insert({&apos;name&apos;:&apos;news&apos;,&apos;group&apos;:&apos;b&apos;})
    db.project.find_one({&apos;group&apos;:&apos;a&apos;})
    for post in db.project.find():
       print post[&apos;name&apos;]
    db.project.remove()

    # 执行mongo命令
    # https://api.mongodb.com/python/current/api/pymongo/database.html
    db.command(&quot;filemd5&quot;, object_id, root=file_root)
    db.command(&quot;dropUser&quot;, &quot;user&quot;)
    db.command(&quot;createUser&quot;, &quot;admin&quot;, pwd=&quot;password&quot;, roles=[&quot;root&quot;])
    for x,y in db.command(&quot;currentOp&quot;).items():
        print x,y

    # currentOp在mongo3.9废弃,建议使用 aggregate()
    with client.admin.aggregate([{&quot;$currentOp&quot;: {}}]) as cursor:
        for operation in cursor:
            print(operation)

python使用redis

    https://pypi.python.org/pypi/redis                  # redis的python官网
    pip install redis  OR easy_install redis            # 安装
    http://redis.readthedocs.org/en/latest/index.html   # redis命令详解
    http://redis.readthedocs.org/en/2.4/index.html

    import redis
    rds = redis.Redis(host=host, port=port, password=passwd, socket_timeout=10,db=0)
    rds.info()                           # redis信息
    rds.set(key, value)                  # 将值value关联到key
    rds.get(key)                         # 取key值
    rds.delete(key1,key2)                # 删除key
    rds.rename(key,new_key2)             # 将key改名 存在覆盖
    rds.seten(key,value)                 # 将值value关联到key,如果key存在不做任何动作
    rds.setex(key, value, 10800)         # 将值value关联到key,并设置key的过期时间
    rds.mset()                           # 同时设置一个或多个key-value对  如果key存在则覆盖
    rds.msetnx()                         # 同时设置一个或多个key-value对  如果有key存在则失败
    rds.mget(key1, key2, key3)           # 取多个key值   不存在返回nil
    rds.expire(key seconds)              # 设置key的过期时间
    rds.persist(key)                     # 移除key的过期时间
    rds.ttl(key)                         # 查看超时时间 -1为不过期
    rds.sadd(key,value1)                 # 将value1加入集合中  集合不重复
    rds.smembers(key)                    # 返回key中所有成员
    rds.scard(key)                       # 集合中元素的数量
    rds.srandmember(key)                 # 对集合随机返回一个元素 而不对集合改动  当key不存在或key是空集时，返回nil
    rds.sinter(key1,key2)                # 两个集合的交集
    rds.sdiff(key1,key2)                 # 两个集合的差集
    rds.sismember(key,value)             # 判断value元素是否是集合key的成员 1存在 0不存在
    rds.lpush(key,value1)                # 将value1加入列表中  从左到右
    rds.lpop(key,value1)                 # 移除并返回列表key的头元素
    rds.llen(key)                        # 返回列表长度
    rds.sort(key)                        # 对列表、集合、有序集合排序[大列表排序非常影响性能，甚至把redis拖死]
    rds.append(key,value)                # 字符串拼接为新的value
    rds.ltrim(key, 0, -10)               # 保留指定区间内的元素，不在都被删除 0第一个 -1最后一个
    rds.incr(key , amount=1)             # 计数加1 默认1或请先设置key的数值
    rds.decr(key)                        # 计数减1 请先设置key的数值
    rds.save()                           # 保存数据

python使用kestrel队列

    # pykestrel
    import kestrel

    q = kestrel.Client(servers=[&apos;127.0.0.1:22133&apos;],queue=&apos;test_queue&apos;)
    q.add(&apos;some test job&apos;)
    job = q.get()    # 从队列读取工作
    job = q.peek()   # 读取下一份工作
    # 读取一组工作
    while True:
        job = q.next(timeout=10) # 完成工作并获取下一个工作，如果没有工作，则等待10秒
        if job is not None:
            try:
                # 流程工作
            except:
                q.abort() # 标记失败工作

    q.finish()  # 完成最后工作
    q.close()   # 关闭连接

    kestrel状态检查
        # kestrel支持memcache协议客户端
        #!/usr/local/bin/python
        # 10.13.81.125 22133  10000

        import memcache
        import sys
        import traceback

        ip=&quot;%s:%s&quot; % (sys.argv[1],sys.argv[2])
        try:
            mc = memcache.Client([ip,])
            st=mc.get_stats()
        except:
            print &quot;kestrel connection exception&quot;
            sys.exit(2)

        if st:
            for s in st[0][1].keys():
                if s.startswith(&apos;queue_&apos;) and s.endswith(&apos;_mem_items&apos;):
                    num = int(st[0][1][s])
                    if num &gt; int(sys.argv[3]):
                        print &quot;%s block to %s&quot; %(s[6:-6],num)
                        sys.exit(2)
            print &quot;kestrel ok!&quot;
            sys.exit(0)
        else:
            print &quot;kestrel down&quot;
            sys.exit(2)

python使用tarantool

    # pip install tarantool-queue

    from tarantool_queue import Queue
    queue = Queue(&quot;localhost&quot;, 33013, 0)     # 连接读写端口 空间0
    tube = queue.tube(&quot;name_of_tube&quot;)        #
    tube.put([1, 2, 3])

    task = tube.take()
    task.data     # take task and read data from it
    task.ack()    # move this task into state DONE

python-etcd

    http://python-etcd.readthedocs.io/en/latest/

    pip install python-etcd
    import etcd
    client = etcd.Client(host=&apos;etcd-01&apos;, port=2379)
    client = etcd.Client( ((&apos;etcd-01&apos;, 2379), (&apos;etcd-02&apos;, 2379), (&apos;etcd-03&apos;, 2379)) ,allow_reconnect=True)   # 集群多IP  allow_reconnect 允许重连

    # 增加 目录必须存在 # 目录: /v1/xuesong/
    client.write(&apos;/v1/xuesong/10.10.10.10:8080&apos;, &apos;test&apos;)
    # 获取指定路径的值
    r = client.read(&apos;/v1/xuesong/10.10.10.10:8080&apos; , recursive=True, sorted=True)
    r.value
    # 删除指定路径
    client.delete(&apos;/v1/xuesong/10.10.10.10:8080&apos;)

    # with ttl
    client.write(&apos;/nodes/n2&apos;, 2, ttl=4)  # sets the ttl to 4 seconds
    # create only
    client.write(&apos;/nodes/n3&apos;, &apos;test&apos;, prevExist=False)
    # Compare and swap values atomically
    client.write(&apos;/nodes/n3&apos;, &apos;test2&apos;, prevValue=&apos;test1&apos;)    #this fails to write
    client.write(&apos;/nodes/n3&apos;, &apos;test2&apos;, prevIndex=10)         #this fails to write
    # mkdir
    client.write(&apos;/nodes/queue&apos;, None, dir=True)
    # Append a value to a queue dir
    client.write(&apos;/nodes/queue&apos;, &apos;test&apos;, append=True)        #will write i.e. /nodes/queue/11
    client.write(&apos;/nodes/queue&apos;, &apos;test2&apos;, append=True)       #will write i.e. /nodes/queue/12

    client.read(&apos;/nodes/n2&apos;).value                           # 获取单个键值
    r = client.read(&apos;/nodes&apos;, recursive=True, sorted=True)   # 递归查询目录
    for i in r.children:
        if not i.dir:
            print(&quot;%s: %s&quot; % (child.key,child.value))

    client.read(&apos;/nodes/n2&apos;, wait=True) #Waits for a change in value in the key before returning.
    client.read(&apos;/nodes/n2&apos;, wait=True, waitIndex=10)

    try:
        client.read(&apos;/invalid/path&apos;)
    except etcd.EtcdKeyNotFound:
        print &quot;error&quot;

    client.delete(&apos;/nodes/n1&apos;)
    client.delete(&apos;/nodes&apos;, dir=True)             #spits an error if dir is not empty
    client.delete(&apos;/nodes&apos;, recursive=True)       #this works recursively

    client.watch(&apos;/nodes/n1&apos;, recursive=True,timeout=0)        # 递归获取改变值 阻塞直到有改变

    # watch只会阻塞监视之后的一次改动，所以必须先递归read下所有路径，然后根据每次的watch进行更改
    # 第一次read的时候，需要记录 etcd_index+1作为下一次watch的索引
    index = client.read(&apos;/nodes/n1&apos;, recursive=True).etcd_index
    while 1:
        # watch后的索引是 modifiedIndex+1传给下一次的watch
        index = client.watch(&apos;/nodes/n1&apos;, recursive=True, timeout=0, index=index+1).modifiedIndex


python操作zookeeper
    https://kazoo.readthedocs.io/en/latest/basic_usage.html

    pip install kazoo
    from kazoo.client import KazooClient

    zk = KazooClient(hosts=&apos;127.0.0.1:2181&apos;, read_only=True)
    zk.start()
    zk.get_children(&apos;/&apos;)
    zk.stop()


python操作elasticsearch

    http://elasticsearch-py.readthedocs.io/en/master/

    from datetime import datetime
    from elasticsearch import Elasticsearch

    es = Elasticsearch([&quot;host1&quot;, &quot;host2&quot;])

    doc = {
        &apos;author&apos;: &apos;kimchy&apos;,
        &apos;text&apos;: &apos;Elasticsearch: cool. bonsai cool.&apos;,
        &apos;timestamp&apos;: datetime.now(),
    }

    res = es.index(index=&quot;live-&quot;, doc_type=&apos;tweet&apos;, id=1, body=doc)
    print(res[&apos;created&apos;])

    res = es.get(index=&quot;live-&quot;, doc_type=&apos;tweet&apos;, id=1)
    print(res[&apos;_source&apos;])

    es.indices.refresh(index=&quot;live-&quot;)

    res = es.search(index=&quot;live-&quot;, body={&quot;query&quot;: {&quot;match_all&quot;: {}}})</code></pre><p>7 http客户端</p>
<pre><code>urllib2        [网络资源访问]

    import urllib2
    response = urllib2.urlopen(&apos;http://baidu.com&apos;)
    print response.geturl()       # url
    headers = response.info()
    print headers                 # web页面头部信息
    print headers[&apos;date&apos;]         # 头部信息中的时间
    date = response.read()        # 返回页面所有信息[字符串]
    # date = response.readlines() # 返回页面所有信息[列表]

    for i in urllib2.urlopen(&apos;http://qq.com&apos;):    # 可直接迭代
        print i,

    下载文件

        #!/usr/bin/env python
        #encoding:utf8
        import urllib2

        url = &apos;http://www.01happy.com/wp-content/uploads/2012/09/bg.png&apos;
        file(&quot;./pic/%04d.png&quot; % i, &quot;wb&quot;).write(urllib2.urlopen(url).read())

    抓取网页解析指定内容

        #!/usr/bin/env python
        #encoding:utf8

        import urllib2
        import urllib
        import random
        from bs4 import BeautifulSoup

        url=&apos;http://www.aaammm.com/aaa/&apos;

        ua=[&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)&quot;,
        &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&quot;,
        &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.2; .NET4.0C; .NET4.0E)&quot;,
        &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.143 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:31.0) Gecko/20100101 Firefox/31.0&quot;,
        &quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.143 Safari/537.36&quot;]

        browser = random.choice(ua)

        req_header = {&apos;User-Agent&apos;:browser,
        &apos;Accept&apos;:&apos;text/html;q=0.9,*/*;q=0.8&apos;,
        &apos;Cookie&apos;:&apos;BAIDUID=4C8274B52CFB79DEB4FBA9A7EC76A1BC:FG=1; BDUSS=1dCdU1WNFdxUll0R09XcnBZTkRrVVVNbWVnSkRKSVRPeVljOUswclBoLUNzVEpVQVFBQUFBJCQAAAAAAAAAAAEAAADEuZ8BcXVhbnpob3U3MjIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIIIkC1SCJAtUY; BD_UPN=123143; BD_HOME=1&apos;,    # 添真实登陆后的Cookie 谷歌浏览器[F12  Network  Documents  Headers]
        &apos;Accept-Charset&apos;:&apos;ISO-8859-1,utf-8;q=0.7,*;q=0.3&apos;,
        &apos;Connection&apos;:&apos;close&apos;,
        }
        #data = urllib.urlencode({&apos;name&apos;:&apos;xuesong&apos;,&apos;id&apos;:&apos;30&apos; })          # urllib 的处理参数的方法，可以再urllib2中使用
        data = urllib2.quote(&quot;pgv_ref=im.perinfo.perinfo.icon&amp;rrr=pppp&quot;)
        req_timeout = 10
        try:
            req = urllib2.Request(url,data=data,headers=req_header)      # data为None 则方法为get，有date为post方法
            html = urllib2.urlopen(req,data=None,req_timeout).read()
        except urllib2.HTTPError as err:
            print str(err)
        except:
            print &quot;timeout&quot;
        print(html)

        # 百度带Cookie后查看自己的用户
        #for i in html.split(&apos;\n&apos;):
        #    if &apos;bds.comm.user=&apos; in i:
        #        print i

        soup = BeautifulSoup(html)
        for i in  soup.find_all(target=&quot;_blank&quot;,attrs={&quot;class&quot;: &quot;usr-pic&quot;}):   # 条件看情况选择
            if i.img:
                print(i.get(&apos;href&apos;))

    模拟浏览器访问web页面 python3
        #! /usr/bin/env python
        # -*- coding=utf-8 -*-
        import urllib.request

        url = &quot;http://www.baidu.com&quot;
        # AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11
        headers = {&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.1)&apos;,
        &apos;Accept&apos;:&apos;text/html;q=0.9,*/*;q=0.8&apos;,
        &apos;Accept-Charset&apos;:&apos;ISO-8859-1,utf-8;q=0.7,*;q=0.3&apos;,
        &apos;Connection&apos;:&apos;close&apos;,
        &apos;Referer&apos;:None #注意如果依然不能抓取的话，这里可以设置抓取网站的host
        }

        opener = urllib.request.build_opener()
        opener.addheaders = [headers]
        data = opener.open(url).read()

        print(data)

requests       [替代urllib2]

    # Requests是一个Python的HTTP客户端库
    # 官方中文文档 http://cn.python-requests.org/zh_CN/latest/user/quickstart.html#id2
    # 安装: sudo pip install requests
    import requests

    # 使用 logging 库时忽略 requests 库的日志
    logging.getLogger(&quot;requests&quot;).setLevel(logging.WARNING)
    logging.getLogger(&quot;urllib3&quot;).setLevel(logging.WARNING)

    # get方法提交表单
    url = r&apos;http://dict.youdao.com/search?le=eng&amp;q={0}&apos;.format(word.strip())
    r = requests.get(url,timeout=2)

    # get方法带参数 http://httpbin.org/get?key=val
    payload = {&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;}
    r = requests.get(&quot;http://httpbin.org/get&quot;, params=payload)

    # post方法提交表单
    QueryAdd=&apos;http://www.anti-spam.org.cn/Rbl/Query/Result&apos;
    r = requests.post(url=QueryAdd, data={&apos;IP&apos;:&apos;211.211.54.54&apos;})

    # 定制请求头post请求
    payload = {&apos;some&apos;: &apos;data&apos;}
    headers = {&apos;content-type&apos;: &apos;application/json&apos;}
    r = requests.post(url, data=json.dumps(payload), headers=headers)

    # https 需登录加auth
    r = requests.get(&apos;https://baidu.com&apos;, auth=(&apos;user&apos;, &apos;pass&apos;))

    if r.ok:    # 判断请求是否正常
        print r.url             # u&apos;http://httpbin.org/get?key2=value2&amp;key1=value1&apos;
        print r.status_code     # 状态码
        print r.content         # 获取到的原始内容  可使用 BeautifulSoup4 解析处理判定结果
        print r.text            # 把原始内容转unicode编码
        print r.headers         # 响应头
        print r.headers[&apos;content-type&apos;]          # 网页头信息 不存在为None
        print r.cookies[&apos;example_cookie_name&apos;]   # 查看cookie
        print r.history         # 追踪重定向 [&lt;Response [301]&gt;]  开启重定向 allow_redirects=True

    获取JSON
        r = requests.get(&apos;https://github.com/timeline.json&apos;)
        r.json()

    获取图片
        from PIL import Image
        from StringIO import StringIO
        i = Image.open(StringIO(r.content))

    发送cookies到服务器
        url = &apos;http://httpbin.org/cookies&apos;
        cookies = dict(cookies_are=&apos;working&apos;)
        r = requests.get(url, cookies=cookies)
        r.text         &apos;{&quot;cookies&quot;: {&quot;cookies_are&quot;: &quot;working&quot;}}&apos;

    在同一个Session实例发出的所有请求之间保持cookies
        s = requests.Session()
        s.get(&apos;http://httpbin.org/cookies/set/sessioncookie/123456789&apos;)
        r = s.get(&quot;http://httpbin.org/cookies&quot;)
        print r.text

    会话对象能够跨请求保持某些参数
        s = requests.Session()
        s.auth = (&apos;user&apos;, &apos;pass&apos;)
        s.headers.update({&apos;x-test&apos;: &apos;true&apos;})
        s.get(&apos;http://httpbin.org/headers&apos;, headers={&apos;x-test2&apos;: &apos;true&apos;})  # both &apos;x-test&apos; and &apos;x-test2&apos; are sent

    ssl证书验证
        requests.get(&apos;https://github.com&apos;, verify=True)
        requests.get(&apos;https://kennethreitz.com&apos;, verify=False)   # 忽略证书验证
        requests.get(&apos;https://kennethreitz.com&apos;, cert=(&apos;/path/server.crt&apos;, &apos;/path/key&apos;))   # 本地指定一个证书 正确 &lt;Response [200]&gt;  错误 SSLError

    流式上传
        with open(&apos;massive-body&apos;) as f:
            requests.post(&apos;http://some.url/streamed&apos;, data=f)

    流式请求
        import requests
        import json

        r = requests.post(&apos;https://stream.twitter.com/1/statuses/filter.json&apos;,
            data={&apos;track&apos;: &apos;requests&apos;}, auth=(&apos;username&apos;, &apos;password&apos;), stream=True)

        for line in r.iter_lines():
            if line: # filter out keep-alive new lines
                print json.loads(line)

    自定义身份验证
        from requests.auth import AuthBase
        class PizzaAuth(AuthBase):
            &quot;&quot;&quot;Attaches HTTP Pizza Authentication to the given Request object.&quot;&quot;&quot;
            def __init__(self, username):
                # setup any auth-related data here
                self.username = username
            def __call__(self, r):
                # modify and return the request
                r.headers[&apos;X-Pizza&apos;] = self.username
                return r
        requests.get(&apos;http://pizzabin.org/admin&apos;, auth=PizzaAuth(&apos;kenneth&apos;))

    基本身份认证
        from requests.auth import HTTPBasicAuth
        requests.get(&apos;https://api.github.com/user&apos;, auth=HTTPBasicAuth(&apos;user&apos;, &apos;pass&apos;))

    摘要式身份认证
        from requests.auth import HTTPDigestAuth
        url = &apos;http://httpbin.org/digest-auth/auth/user/pass&apos;
        requests.get(url, auth=HTTPDigestAuth(&apos;user&apos;, &apos;pass&apos;))

    代理
        import requests
        proxies = {
          &quot;http&quot;: &quot;http://10.10.1.10:3128&quot;,
          # &quot;http&quot;: &quot;http://user:pass@10.10.1.10:3128/&quot;,  # 用户名密码
          &quot;https&quot;: &quot;http://10.10.1.10:1080&quot;,
        }
        requests.get(&quot;http://example.org&quot;, proxies=proxies)
        #也可以设置环境变量之间访问
        export HTTP_PROXY=&quot;http://10.10.1.10:3128&quot;
        export HTTPS_PROXY=&quot;http://10.10.1.10:1080&quot;


    requests.session
        import requests
        import time
        from bs4 import BeautifulSoup

        session = requests.session()

        login_url = &quot;http://deploy.ixiaochuan.cn/login&quot;
        res_start = session.get(url=login_url)
        bs = BeautifulSoup(res_start.text, &quot;html.parser&quot;)
        a = bs.select(&quot;#csrf_token&quot;)[0]
        token = a.attrs.get(&quot;value&quot;)

        login_data = {&quot;username&quot;: (None, &quot;weiqiang&quot;), &quot;password&quot;: (None, &quot;Onei&quot;), &quot;submit&quot;: (None, &quot;Login&quot;),
                      &quot;csrf_token&quot;: (None, token)}
        res = session.post(url=login_url, files=login_data, allow_redirects=False)
        print(&quot;login success&quot;)


BeautifulSoup  [html\xml解析器]

    # BeautifulSoup中文官方文档
    # http://www.crummy.com/software/BeautifulSoup/bs3/documentation.zh.html
    # http://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html
    # Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: Tag , NavigableString , BeautifulSoup , Comment

    导入模块
        from BeautifulSoup import BeautifulSoup          # For processing HTML  版本3.0 已停止更新
        from BeautifulSoup import BeautifulStoneSoup     # For processing XML
        import BeautifulSoup                             # To get everything
        from bs4 import BeautifulSoup                    # 版本4.0 bs4 安装: pip install BeautifulSoup4

    from bs4 import BeautifulSoup
    soup = BeautifulSoup(html_doc)         # 解析html文本 可以是 requests 提交返回的页面 results.content
    print(soup.prettify())                 # 输出解析后的结构
    print(soup.title)                      # 指定标签内容
    print(soup.title.name)                 # 标签名
    print(soup.title.string)               # 标签内容
    print(soup.title.parent.name)          # 上层标签名
    print(soup.p)                          # &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt;
    print(soup.p[&apos;class&apos;])                 # u&apos;title&apos;  class属性值
    print(soup.a)                          # 找到第一个a标签的标签行
    print(soup.find_all(&apos;a&apos;,limit=2))      # 找到a标签的行,最多为limit个
    print(soup.find(id=&quot;link3&quot;))           # 标签内id为link3的标签行
    print(soup.get_text())                 # 从文档中获取所有文字内容
    soup.find_all(&quot;a&quot;, text=&quot;Elsie&quot;)       # 从文档中搜索关键字
    soup.find(text=re.compile(&quot;sisters&quot;))  # 从文档中正则搜索关键字
    soup.find_all(&quot;a&quot;, class_=&quot;sister&quot;)    # 按CSS搜索
    soup.find_all(id=&apos;link2&apos;,&quot;table&quot;,attrs={&quot;class&quot;: &quot;status&quot;},href=re.compile(&quot;elsie&quot;))   # 搜索方法
    for i in  soup.find_all(&apos;a&apos;,attrs={&quot;class&quot;: &quot;usr-pic&quot;}):    # 循环所有a标签的标签行
            if i.a.img:
                    print(i.a.img.get(&quot;src&quot;))                   # 取出当前a标签中的连接
    Tag
        # find_all 后循环的值是 Tag 不是字符串 不能直接截取
        tag.text                     # 文本
        tag.name
        tag.name = &quot;blockquote&quot;      # 查找name为 blockquote 的
        tag[&apos;class&apos;]
        tag.attrs                    # 按熟悉查找
        tag[&apos;class&apos;] = &apos;verybold&apos;

        del tag[&apos;class&apos;]             # 删除
        print(tag.get(&apos;class&apos;))      # 打印属性值
        print(i.get(&apos;href&apos;))         # 打印连接

cookielib      [保留cookie登录页面]

    ck = cookielib.CookieJar()   # 通过 这个就可以实现请求带过去的COOKIE与发送回来的COOKIE值了。
    opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(ck))   # 获取到COOKIE
    urllib2.install_opener(opener)   # 此句设置urllib2的全局opener
    content = urllib2.urlopen(url).read()

    登录cacti取图片
        #encoding:utf8
        import urllib2
        import urllib
        import cookielib
        def renrenBrower(url,user,password):
            #查找form标签中的action提交地址
            login_page = &quot;http://10.10.10.19/cacti/index.php&quot;
            try:
                #获得一个cookieJar实例
                cj = cookielib.CookieJar()
                #cookieJar作为参数，获得一个opener的实例
                opener=urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))
                #伪装成一个正常的浏览器，避免有些web服务器拒绝访问
                opener.addheaders = [(&apos;User-agent&apos;,&apos;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&apos;)]
                #生成Post数据,含有登陆用户名密码,所有表单内的input中name值
                data = urllib.urlencode({&quot;action&quot;:&quot;login&quot;,&quot;login_username&quot;:user,&quot;login_password&quot;:password})
                #以post的方法访问登陆页面，访问之后cookieJar会自定保存cookie
                opener.open(login_page,data)
                #以带cookie的方式访问页面
                op=opener.open(url)
                #读取页面源码
                data=op.read()
                #将图片写到本地
                #file(&quot;1d.png&quot; , &quot;wb&quot;).write(data)
                return data
            except Exception,e:
                print str(e)
        print renrenBrower(&quot;http://10.10.10.19/cacti/graph_image.php?local_graph_id=1630&amp;rra_id=0&amp;view_type=tree&amp;graph_start=1397525517&amp;graph_end=1397611917&quot;,&quot;admin&quot;,&quot;admin&quot;)

    例子2
        import urllib, urllib2, cookielib
        import os, time

        headers = []

        def login():
            cj = cookielib.CookieJar()
            opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))
            login_url = r&apos;http://zhixing.bjtu.edu.cn/member.php?mod=logging&amp;action=login&amp;loginsubmit=yes&amp;infloat=yes&amp;lssubmit=yes&amp;inajax=1&apos;
            login_data = urllib.urlencode({&apos;cookietime&apos;: &apos;2592000&apos;, &apos;handlekey&apos;: &apos;ls&apos;, &apos;password&apos;: &apos;xxx&apos;,
                    &apos;quickforward&apos;: &apos;yes&apos;, &apos;username&apos;: &apos;GuoYuan&apos;})
            opener.addheaders = [(&apos;Host&apos;, &apos;zhixing.bjtu.edu.cn&apos;),
                               (&apos;User-Agent&apos;, &apos;Mozilla/5.0 (Ubuntu; X11; Linux i686; rv:8.0) Gecko/20100101 Firefox/8.0&apos;),
                               (&apos;Accept&apos;, &apos;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&apos;),
                               (&apos;Accept-Language&apos;, &apos;en-us,en;q=0.5&apos;),
                               (&apos;Accept-Encoding&apos;, &apos;gzip, deflate&apos;),
                               (&apos;Accept-Charset&apos;, &apos;ISO-8859-1,utf-8;q=0.7,*;q=0.7&apos;),
                               (&apos;Connection&apos;, &apos;keep-alive&apos;),
                               (&apos;Referer&apos;, &apos;http://zhixing.bjtu.edu.cn/forum.php&apos;),]
            opener.open(login_url, login_data)
            return opener

        if __name__ == &apos;__main__&apos;:
            opener = login()

            url = r&apos;http://zhixing.bjtu.edu.cn/forum.php?mod=topicadmin&amp;action=moderate&amp;optgroup=2&amp;modsubmit=yes&amp;infloat=yes&amp;inajax=1&apos;
            data = {&apos;fid&apos;: &apos;601&apos;, &apos;formhash&apos;: &apos;0cdd1596&apos;, &apos;frommodcp&apos;: &apos;&apos;, &apos;handlekey&apos;: &apos;mods&apos;,
                     &apos;listextra&apos;: &apos;page%3D62&apos;, &apos;moderate[]&apos;: &apos;496146&apos;, &apos;operations[]&apos;: &apos;type&apos;, &apos;reason&apos;: &apos;...&apos;,
                     &apos;redirect&apos;: r&apos;http://zhixing.bjtu.edu.cn/thread-496146-1-1.html&apos;, &apos;typeid&apos;: &apos;779&apos;}
            data2 = [(k, v) for k,v in data.iteritems()]

            cnt = 0
            for tid in range(493022, 496146 + 1):
                cnt += 1
                if cnt % 20 == 0: print
                print tid,

                data2.append((&apos;moderate[]&apos;, str(tid)))
                if cnt % 40 == 0 or cnt == 496146:
                    request = urllib2.Request(url=url, data=urllib.urlencode(data2))
                    print opener.open(request).read()
                    data2 = [(k, v) for k,v in data.iteritems()]

httplib        [http协议的客户端]

    import httplib
    conn3 = httplib.HTTPConnection(&apos;www.baidu.com&apos;,80,True,10)

aiohttp        [检索网页的客户端]

    # 需要python3.3+
    # http://aiohttp.readthedocs.org/en/v0.12.0/

    import aiohttp

    def get_body(url):
        response = yield from aiohttp.request(&apos;GET&apos;, url)
        return (yield from response.read())

    response = yield from aiohttp.request(&apos;GET&apos;, &apos;http://python.org&apos;)
    body = yield from response.read()
    print(body)

    # 用 asyncio 配合协程抓取页面
    yield from asyncio.wait_for(request(&apos;GET&apos;, url), 10)

    http_server

        import asyncio
        from aiohttp import web

        @asyncio.coroutine
        def handle(request):
            name = request.match_info.get(&apos;name&apos;, &quot;Anonymous&quot;)
            text = &quot;Hello, &quot; + name
            return web.Response(body=text.encode(&apos;utf-8&apos;))

        @asyncio.coroutine
        def init(loop):
            app = web.Application(loop=loop)
            app.router.add_route(&apos;GET&apos;, &apos;/{name}&apos;, handle)

            srv = yield from loop.create_server(app.make_handler(),
                                                &apos;127.0.0.1&apos;, 8080)
            print(&quot;Server started at http://127.0.0.1:8080&quot;)
            return srv

        loop = asyncio.get_event_loop()
        loop.run_until_complete(init(loop))
        loop.run_forever()

查看网页图片尺寸类型

    #将图片读入内存
    #!/usr/bin/env python
    #encoding=utf-8
    import cStringIO, urllib2, Image
    url = &apos;http://www.01happy.com/wp-content/uploads/2012/09/bg.png&apos;
    file = urllib2.urlopen(url)
    tmpIm = cStringIO.StringIO(file.read())
    im = Image.open(tmpIm)
    print im.format, im.size, im.mode

爬虫

    #!/usr/bin/env python
    #encoding:utf-8
    #sudo pip install BeautifulSoup

    import requests
    from BeautifulSoup import BeautifulSoup
    import re

    baseurl = &apos;http://blog.sina.com.cn/s/articlelist_1191258123_0_1.html&apos;

    r = requests.get(baseurl)

    for url in re.findall(&apos;&lt;a.*?&lt;/a&gt;&apos;, r.content, re.S):
        if url.startswith(&apos;&lt;a title=&apos;):
            with open(r&apos;d:/final.txt&apos;, &apos;ab&apos;) as f:
                f.write(url + &apos;\n&apos;)

    linkfile = open(r&apos;d:/final.txt&apos;, &apos;rb&apos;)
    soup = BeautifulSoup(linkfile)
    for link in soup.findAll(&apos;a&apos;):
        #print link.get(&apos;title&apos;) + &apos;:    &apos; + link.get(&apos;href&apos;)
        ss = requests.get(link.get(&apos;href&apos;))
        for content in re.findall(&apos;&lt;div id=&quot;sina_keyword_ad_area2&quot; class=&quot;articalContent  &quot;&gt;.*?&lt;/div&gt;&apos;, ss.content, re.S):
            with open(r&apos;d:/myftp/%s.txt&apos;%link.get(&apos;title&apos;).strip(&apos;&lt;&gt;&apos;), &apos;wb&apos;) as f:
                f.write(content)
                print &apos;%s   has been copied.&apos; % link.get(&apos;title&apos;)

反垃圾邮件提交申诉

    #很遗憾，反垃圾邮件联盟改版后加了验证码

    #!/usr/bin/env python
    #encoding:utf-8
    import requests
    import re

    IpList=[&apos;113.212.91.25&apos;,&apos;113.212.91.23&apos;]
    QueryAdd=&apos;http://www.anti-spam.org.cn/Rbl/Query/Result&apos;
    ComplaintAdd=&apos;http://www.anti-spam.org.cn/Rbl/Getout/Submit&apos;
    data = {
    &apos;CONTENT&apos;:&apos;&apos;&apos;我们是一家正规的XXX。xxxxxxx。恳请将我们的发送服务器IP移出黑名单。谢谢！
    处理措施：
    1.XXXX。
    2.XXXX。&apos;&apos;&apos;,
    &apos;CORP&apos;:&apos;abc.com&apos;,
    &apos;WWW&apos;:&apos;www.abc.cm&apos;,
    &apos;NAME&apos;:&apos;def&apos;,
    &apos;MAIL&apos;:&apos;def@163.com.cn&apos;,
    &apos;TEL&apos;:&apos;010-50000000&apos;,
    &apos;LEVEL&apos;:&apos;0&apos;,
    }

    for Ip in IpList:
        query = requests.post(url=QueryAdd, data={&apos;IP&apos;:Ip})                   # 黑名单查询
        if query.ok:
            if re.findall(u&apos;\u7533\u8bc9\u8131\u79bb&apos;, query.text, re.S):     # 查找关键字 申诉脱离 既表明在黑名单中
                data[&apos;IP&apos;]=Ip
                complaint = requests.post(url=ComplaintAdd, data=data)        # 提交申诉
                if complaint.ok:
                    if re.findall(u&apos;\u60a8\u7684\u9ed1\u540d\u5355\u8131\u79bb\u7533\u8bf7\u5df2\u63d0\u4ea4&apos;, complaint.text, re.S):
                        status=&apos;申请提交&apos;
                    elif re.findall(u&apos;\u8131\u79bb\u7533\u8bf7\u5df2\u88ab\u4ed6\u4eba\u63d0\u4ea4&apos;, complaint.text, re.S):
                        status=&apos;重复提交&apos;
                    elif re.findall(u&apos;\u7533\u8bf7\u7531\u4e8e\u8fd1\u671f\u5185\u6709\u88ab\u62d2\u7edd\u7684\u8bb0\u5f55&apos;, complaint.text, re.S):
                        status=&apos;近期拒绝&apos;
                    else:
                        status=&apos;异常&apos;
            else:
                status=&apos;正常&apos;
            print &apos;%s  %s&apos; %(Ip,status)

有道词典

    #!/usr/bin/env python
    import requests
    from bs4 import BeautifulSoup
    # bs4安装: pip install BeautifulSoup4

    def youdao(word):
        url = r&apos;http://dict.youdao.com/search?le=eng&amp;q={0}&apos;.format(word.strip())
        r = requests.get(url)
        if r.ok:
            soup = BeautifulSoup(r.content)
            div = soup.find_all(&apos;div&apos;, class_=&apos;trans-container&apos;)[:1]    # find_all是bs4的方法
            ul = BeautifulSoup(str(div[0]))
            li = ul.find_all(&apos;li&apos;)
            for mean in li:
                print mean.text

    def query():
        print(&apos;Created by @littlepy, QQ:185635687&apos;)
        while True:
            word = raw_input(&apos;&gt;&gt;&gt;&apos;)
            youdao(word)

    if __name__ == &apos;__main__&apos;:
        query()

python启动http服务提供访问或下载

    python -m SimpleHTTPServer  9900</code></pre><p>8 并发</p>
<pre><code>#线程安全/竞争条件,锁/死锁检测,线程池,生产消费模型,伪并发,微线程,协程
#Stackless Python 是Python编程语言的一个增强版本，它使程序员从基于线程的编程方式中获得好处，并避免传统线程所带来的性能与复杂度问题。Stackless为 Python带来的微线程扩展，是一种低开销、轻量级的便利工具

Queue队列
    import Queue
    q = = Queue.Queue(3)

    q.put(&apos;a&apos;, True, 5)              # True等待超时时间, False不等待
    if q.full():                     # 队列满了返回True,反之False
        q.qsize()                    # 队列长度
        workQueue.queue.clear()      # 清空队列
    q.get(True,5)                    # True等待超时时间, False不等待

threading多线程

    thread
        start_new_thread(function,args kwargs=None)    # 产生一个新的线程
        allocate_lock()                                # 分配一个LockType类型的锁对象
        exit()                                         # 让线程退出
        acquire(wait=None)                             # 尝试获取锁对象
        locked()                                       # 如果获取了锁对象返回True
        release()                                      # 释放锁

    thread例子

        #!/usr/bin/env python
        #thread_test.py
        #不支持守护进程
        import thread
        from time import sleep,ctime

        loops = [4,2]

        def loop(nloop,nsec,lock):
            print &apos;start loop %s at:%s&apos; % (nloop,ctime())
            sleep(nsec)
            print &apos;loop %s done at: %s&apos; % (nloop, ctime())
            lock.release()              # 分配已获得的锁,操作结束后释放相应的锁通知主线程

        def main():
            print &apos;starting at:&apos;,ctime()
            locks = []
            nloops = range(len(loops))

            for i in nloops:
                lock = thread.allocate_lock()     # 创建一个锁
                lock.acquire()                    # 调用各个锁的acquire()函数获得锁
                locks.append(lock)                # 把锁放到锁列表locks中
            for i in nloops:
                thread.start_new_thread(loop,(i,loops[i],locks[i]))   # 创建线程
            for i in nloops:
                while locks[i].locked():pass      # 等待全部解锁才继续运行
            print &apos;all DONE at:&apos;,ctime()

        if __name__ == &apos;__main__&apos;:
            main()

    thread例子1

        #coding=utf-8
        import thread,time,os

        def f(name):
                i =3
                while i:
                        time.sleep(1)
                        print name
                        i -= 1
                # os._exit()   会把整个进程关闭
                os._exit(22)

        if __name__ == &apos;__main__&apos;:
                thread.start_new_thread(f,(&quot;th1&quot;,))
                while 1:
                        pass
                os._exit(0)

    threading
        Thread                   # 表示一个线程的执行的对象
            start()              # 开始线程的执行
            run()                # 定义线程的功能的函数(一般会被子类重写)
            join(timeout=None)   # 允许主线程等待线程结束,程序挂起,直到线程结束;如果给了timeout,则最多等待timeout秒.
            getName()            # 返回线程的名字
            setName(name)        # 设置线程的名字
            isAlive()            # 布尔标志,表示这个线程是否还在运行中
            isDaemon()           # 返回线程的daemon标志
            setDaemon(daemonic)  # 后台线程,把线程的daemon标志设置为daemonic(一定要在调用start()函数前调用)
            # 默认主线程在退出时会等待所有子线程的结束。如果希望主线程不等待子线程，而是在退出时自动结束所有的子线程，就需要设置子线程为后台线程(daemon)
        Lock              # 锁原语对象
        Rlock             # 可重入锁对象.使单线程可以在此获得已获得了的锁(递归锁定)
        Condition         # 条件变量对象能让一个线程停下来,等待其他线程满足了某个条件.如状态改变或值的改变
        Event             # 通用的条件变量.多个线程可以等待某个事件的发生,在事件发生后,所有的线程都会被激活
        Semaphore         # 为等待锁的线程提供一个类似等候室的结构
        BoundedSemaphore  # 与Semaphore类似,只是不允许超过初始值
        Time              # 与Thread相似,只是他要等待一段时间后才开始运行
        activeCount()     # 当前活动的线程对象的数量
        currentThread()   # 返回当前线程对象
        enumerate()       # 返回当前活动线程的列表
        settrace(func)    # 为所有线程设置一个跟踪函数
        setprofile(func)  # 为所有线程设置一个profile函数

    threading例子1

        #!/usr/bin/env python
        #encoding:utf8
        import threading
        from Queue import Queue
        from time import sleep,ctime

        class ThreadFunc(object):
                def __init__(self,func,args,name=&apos;&apos;):
                        self.name=name
                        self.func=func                    # loop
                        self.args=args                    # (i,iplist[i],queue)
                def __call__(self):
                        apply(self.func,self.args)        # 函数apply() 执行loop函数并传递元组参数
        def loop(nloop,ip,queue):
                print &apos;start&apos;,nloop,&apos;at:&apos;,ctime()
                queue.put(ip)
                sleep(2)
                print &apos;loop&apos;,nloop,&apos;done at:&apos;,ctime()
        if __name__ == &apos;__main__&apos;:
                threads = []
                queue = Queue()
                iplist = [&apos;192.168.1.2&apos;,&apos;192.168.1.3&apos;,&apos;192.168.1.4&apos;,&apos;192.168.1.5&apos;,&apos;192.168.1.6&apos;,&apos;192.168.1.7&apos;,&apos;192.168.1.8&apos;]
                nloops = range(len(iplist))

                for i in nloops:
                        t = threading.Thread(target=ThreadFunc(loop,(i,iplist[i],queue),loop.__name__))
                        threads.append(t)
                for i in nloops:
                        threads[i].start()
                for i in nloops:
                        threads[i].join()
                for i in nloops:
                        print queue.get()

    threading例子2

        #!/usr/bin/env python
        #encoding:utf8
        from Queue import Queue
        import random,time,threading

        class Producer(threading.Thread):
            def __init__(self, t_name, queue):
                threading.Thread.__init__(self, name=t_name)
                self.data=queue
            def run(self):
                for i in range(5):
                    print &quot;%s: %s is producing %d to the queue!\n&quot; %(time.ctime(), self.getName(), i)
                    self.data.put(i)
                    self.data.put(i*i)
                    time.sleep(2)
                print &quot;%s: %s finished!&quot; %(time.ctime(), self.getName())

        class Consumer(threading.Thread):
            def __init__(self, t_name, queue):
                threading.Thread.__init__(self, name=t_name)
                self.data=queue
            def run(self):
                for i in range(10):
                    val = self.data.get()
                    print &quot;%s: %s is consuming. %d in the queue is consumed!\n&quot; %(time.ctime(), self.getName(), val)
                print &quot;%s: %s finished!&quot; %(time.ctime(), self.getName())

        if __name__ == &apos;__main__&apos;:
            queue = Queue()
            producer = Producer(&apos;Pro.&apos;, queue)
            consumer = Consumer(&apos;Con.&apos;, queue)
            producer.start()
            consumer.start()
            producer.join()
            consumer.join()

    threading例子3

        # 启动线程后自动执行 run函数其他不可以
        import threading
        import time

        class Th(threading.Thread):
            def __init__(self,name):
                threading.Thread.__init__(self)
                self.t_name=name
                self.daemon = True     # 默认为false，让主线程等待处理完成
            def run(self):
                time.sleep(1)
                print &quot;this is &quot; + self.t_name

        if __name__ == &apos;__main__&apos;:
            thread1 = Th(&quot;Th_1&quot;)
            thread1.start()

    threading例子4

        import threading
        import time
        class Th(threading.Thread):
            def __init__(self,thread_name):
                threading.Thread.__init__(self)
                self.setName(thread_name)
            def run(self):
                threadLock.acquire()
                print self.getName()
                for i in range(3):
                    time.sleep(1)
                    print str(i)
                print self.getName() +  &quot; is over&quot;
                threadLock.release()

        if __name__ == &apos;__main__&apos;:
            threadLock = threading.Lock()
            thread1 = Th(&quot;Th_1&quot;)
            thread2 = Th(&quot;Th_2&quot;)
            thread1.start()
            thread2.start()

    后台线程

        import threading
        import time,random

        class MyThread(threading.Thread):
            def run(self):
                wait_time=random.randrange(1,10)
                print &quot;%s will wait %d seconds&quot; % (self.name, wait_time)
                time.sleep(wait_time)
                print &quot;%s finished!&quot; % self.name

        if __name__==&quot;__main__&quot;:
            for i in range(5):
                t = MyThread()
                t.setDaemon(True)    # 设置为后台线程,主线程完成时不等待子线程完成就结束
                t.start()

    threading控制最大并发_查询日志中IP信息

        #!/usr/bin/env python
        #coding:utf-8
        import urllib2
        import json
        import threading
        import time

        &apos;&apos;&apos;
        by:某大牛
        QQ:185635687
        这个是多线程并发控制. 如果要改成多进程，只需把threading 换成 mulitprocessing.Process ， 对， 就是换个名字而已.
        &apos;&apos;&apos;

        #获取ip 及其出现次数
        def ip_dic(file_obj, dic):
            for i in file_obj:
                if i:
                    ip=i.split(&apos;-&apos;)[0].strip()
                    if ip in dic.keys():
                        dic[ip]=dic[ip] + 1
                    else:
                        dic[ip]=1
            return dic.iteritems()

        #目标函数
        def get_data(url, ipcounts):
            data=urllib2.urlopen(url).read()
            datadict=json.loads(data)
            fdata = u&quot;ip:%s---%s,%s,%s,%s,%s&quot; %(datadict[&quot;data&quot;][&quot;ip&quot;],ipcounts,datadict[&quot;data&quot;][&quot;country&quot;],datadict[&quot;data&quot;][&quot;region&quot;],datadict[&quot;data&quot;][&quot;city&quot;],datadict[&quot;data&quot;][&quot;isp&quot;])
            print fdata

        #多线程
        def threads(iters):
            thread_pool = []
            for k in iters:
                url = &quot;http://ip.taobao.com/service/getIpInfo.php?ip=&quot;
                ipcounts = k[1]
                url = (url + k[0]).strip()
                t = threading.Thread(target=get_data, args=(url, ipcounts))
                thread_pool.append(t)
            return thread_pool

        #控制多线程
        def startt(t_list, max,second):
            l = len(t_list)
            n = max
            while l &gt; 0:
                if l &gt; max:
                    nl = t_list[:max]
                    t_list = t_list[max:]
                    for t in nl:
                        t.start()
                    time.sleep(second)
                    for t in nl:
                        t.join()
                    print &apos;*&apos;*15,  str(n)+ &apos; ip has been queried&apos;+&apos;*&apos;*15
                    n += max
                    l = len(t_list)
                    continue
                elif l &lt;= max:
                    nl = t_list
                    for t in nl:
                        t.start()
                    for t in nl:
                        t.join()
                    print &apos;&gt;&gt;&gt; Totally &apos; + str(n+l ) + &apos; ip has been queried&apos;
                    l = 0

        if __name__ ==&quot;__main__&quot;:
            dic={}
            with open(&apos;access.log&apos;) as file_obj:
                it = ip_dic(file_obj, dic)
                t_list= threads(it)
                startt(t_list, 15, 1)

    多线程取队列

        #!/usr/bin/python

        import Queue
        import threading
        import time

        exitFlag = 0

        class myThread(threading.Thread):
            def __init__(self, threadID, name, q):
                threading.Thread.__init__(self)
                self.threadID = threadID
                self.name = name
                self.q = q
            def run(self):
                print &quot;Starting &quot; + self.name
                process_data(self.name, self.q)
                print &quot;Exiting &quot; + self.name

        def process_data(threadName, q):
            while not exitFlag:      # 死循环等待
                queueLock.acquire()
                if not q.empty():    # 判断队列是否为空
                    data = q.get()
                    print &quot;%s processing %s&quot; % (threadName, data)
                queueLock.release()
                time.sleep(1)

        nameList = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;]
        queueLock = threading.Lock()     # 锁与队列并无任何关联，其他线程也进行取锁操作的时候就会检查是否有被占用，有就阻塞等待解锁为止
        workQueue = Queue.Queue(10)
        threads = []
        threadID = 1

        # Create new threads
        for threadID in range(100):
            thread = myThread(threadID, &apos;tName%s&apos; % threadID, workQueue)
            thread.start()
            threads.append(thread)
            threadID += 1

        # Fill the queue
        queueLock.acquire()
        for word in nameList:
            workQueue.put(word)
        queueLock.release()

        # Wait for queue to empty
        while not workQueue.empty():   # 死循环判断队列被处理完毕
            pass

        # Notify threads it&apos;s time to exit
        exitFlag = 1

        # Wait for all threads to complete
        for t in threads:
            t.join()
        print &quot;Exiting Main Thread&quot;

Queue通用队列

    q=Queue(size)       # 创建大小size的Queue对象
    qsize()             # 返回队列的大小(返回时候,可能被其他进程修改,近似值)
    empty()             # 如果队列为空返回True，否则False
    full()              # 如果队列已满返回True，否则False
    put(item,block0)    # 把item放到队列中,如果给了block(不为0),函数会一直阻塞到队列中有空间为止
    get(block=0)        # 从队列中取一个对象,如果给了block(不为0),函数会一直阻塞到队列中有对象为止
    get_nowait          # 默认get阻塞，这个不阻塞

multiprocessing [多进程并发]

    线程池

        import urllib2
        from multiprocessing.dummy import Pool as ThreadPool

        urls=[&apos;http://www.baidu.com&apos;,&apos;http://www.sohu.com&apos;]

        pool=ThreadPool(4)   # 线程池
        results=pool.map(urllib2.urlopen,urls)
        pool.close()
        pool.join()

    进程并发

        #!/usr/bin/env python
        #encoding:utf8
        from multiprocessing import Process
        import time,os
        def f(name):
            time.sleep(1)
            print &apos;hello &apos;,name
            print os.getppid()   # 取得父进程ID
            print os.getpid()    # 取得进程ID
        process_list = []

        for i in range(10):
            p = Process(target=f,args=(i,))
            p.start()
            process_list.append(p)
        for j in process_list:
            j.join()

    进程池

        #!/usr/bin/env python
        #encoding:utf8
        from multiprocessing import Pool
        import time,os
        def f(name):
            time.sleep(1)
            print &apos;hello &apos;,name
            print os.getppid()
            print os.getpid()
        process_list = []

        pool = Pool(4)
        res = pool.map(f, range(1,10))
        pool.close()
        pool.join()

    Queue进程间通信

        from multiprocessing import Process,Queue
        import time
        def f(name):
            time.sleep(1)
            q.put([&apos;hello&apos;+str(name)])
        process_list = []
        q = Queue()
        if __name__ == &apos;__main__&apos;:
            for i in range(10):
                p = Process(target=f,args=(i,))
                p.start()
                process_list.append(p)
            for j in process_list:
                j.join()
            for i in range(10):
                print q.get()

    Pipe管道 # 单项通信

        from multiprocessing import Process,Pipe
        import time
        import os

        def f(conn,name):
            time.sleep(1)
            conn.send([&apos;hello&apos;+str(name)])
            print os.getppid(),&apos;-----------&apos;,os.getpid()
        process_list = []
        parent_conn,child_conn = Pipe()
        if __name__ == &apos;__main__&apos;:
            for i in range(10):
                p = Process(target=f,args=(child_conn,i))
                p.start()
                process_list.append(p)
            for j in process_list:
                j.join()
            for p in range(10):
                print parent_conn.recv()

    进程间同步
        #加锁,使某一时刻只有一个进程,其他在调用同一个锁就会被阻塞
        from multiprocessing import Process,Lock
        import time
        import os

        def f(name):
            lock.acquire()
            time.sleep(1)
            print &apos;hello--&apos;+str(name)
            print os.getppid(),&apos;-----------&apos;,os.getpid()
            lock.release()
        process_list = []
        lock = Lock()
        if __name__ == &apos;__main__&apos;:
            for i in range(10):
                p = Process(target=f,args=(i,))
                p.start()
                process_list.append(p)
            for j in process_list:
                j.join()

    共享内存 # 双向通信

        # 通过使用Value或者Array把数据存储在一个共享的内存表中
        # &apos;d&apos;和&apos;i&apos;参数是num和arr用来设置类型，d表示一个双精浮点类型，i表示一个带符号的整型。
        from multiprocessing import Process,Value,Array
        import time
        import os

        def f(n,a,name):
            time.sleep(1)
            n.value = name * name
            for i in range(len(a)):
                a[i] = -i
        process_list = []
        if __name__ == &apos;__main__&apos;:
            num = Value(&apos;d&apos;,0.0)
            arr = Array(&apos;i&apos;,range(10))
            for i in range(10):
                p = Process(target=f,args=(num,arr,i))
                p.start()
                process_list.append(p)
            for j in process_list:
                j.join()
            print num.value
            print arr[:]

    manager

        # 比共享内存灵活,但缓慢
        # 支持list,dict,Namespace,Lock,Semaphore,BoundedSemaphore,Condition,Event,Queue,Ｖalue,Array
        from multiprocessing import Process,Manager
        import time
        import os

        def f(d,name):
            time.sleep(1)
            d[name] = name * name
            print d
        process_list = []
        if __name__ == &apos;__main__&apos;:
            manager = Manager()
            d = manager.dict()
            for i in range(10):
                p = Process(target=f,args=(d,i))
                p.start()
                process_list.append(p)
            for j in process_list:
                j.join()
                print d

    最大并发数

        import multiprocessing
        import time,os

        result = []
        def run(h):
            print &apos;threading:&apos; ,h,os.getpid()
        p = multiprocessing.Pool(processes=20)

        for i in range(100):
            result.append(p.apply_async(run,(i,)))
        p.close()

        for res in result:
            res.get(timeout=5)

gevent          [轻量级协程]

    # 在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。
    # http://xlambda.com/gevent-tutorial/

    锁的使用

        # 同时允许多个协程操作对象的锁,通过互斥访问,保证资源只在程序上下文被单次使用
        from gevent import sleep
        from gevent.pool import Pool
        from gevent.coros import BoundedSemaphore

        sem = BoundedSemaphore(2)        # 超过2就会阻塞等待

        def worker1(n):
            sem.acquire()
            print(&apos;Worker %i acquired semaphore&apos; % n)
            sleep(0)
            sem.release()
            print(&apos;Worker %i released semaphore&apos; % n)

        def worker2(n):
            with sem:
                print(&apos;Worker %i acquired semaphore&apos; % n)
                sleep(0)
            print(&apos;Worker %i released semaphore&apos; % n)

        pool = Pool()
        pool.map(worker1, xrange(0,2))
        pool.map(worker2, xrange(3,6))

    事件

        # Event 阻塞事件
        import gevent
        from gevent.event import Event

        evt = Event()

        def setter():
            &apos;&apos;&apos;After 3 seconds, wake all threads waiting on the value of evt&apos;&apos;&apos;
            print(&apos;A: Hey wait for me, I have to do something&apos;)
            gevent.sleep(3)
            print(&quot;Ok, I&apos;m done&quot;)
            evt.set()                 # 表示事件完成

        def waiter():
            &apos;&apos;&apos;After 3 seconds the get call will unblock&apos;&apos;&apos;
            print(&quot;I&apos;ll wait for you&quot;)
            evt.wait()                # 阻塞等待事件完成
            print(&quot;It&apos;s about time&quot;)

        gevent.joinall([
            gevent.spawn(setter),
            gevent.spawn(waiter),
            gevent.spawn(waiter),
            gevent.spawn(waiter),
            gevent.spawn(waiter),
            gevent.spawn(waiter)
        ])

        # AsyncResult 可传值的事件
        import gevent
        from gevent.event import AsyncResult
        a = AsyncResult()

        def setter():
            gevent.sleep(3)
            a.set(&apos;Hello!&apos;)            # 事件传值

        def waiter():
            &quot;&quot;&quot;
            After 3 seconds the get call will unblock after the setter
            puts a value into the AsyncResult.
            &quot;&quot;&quot;
            print(a.get())             # 获取时间值

        gevent.joinall([
            gevent.spawn(setter),
            gevent.spawn(waiter),
        ])

    队列

        #/usr/local/python
        #encoding:utf8
        import gevent
        from gevent.pool import Pool
        from gevent.coros import BoundedSemaphore
        from gevent.queue import Queue, Empty
        import os

        tasks = Queue(maxsize=30)         # 队列 超过30引发 gevent.hub.LoopExit
        tasks1 = Queue()

        def boss():
            print &apos;放队列任务&apos;
            for i in xrange(1,25):
                tasks.put(i)

        def worker1(n):
            print len(pool)
            while not tasks.empty():      # 判断队列是否为空
                task = tasks.get()        # 获取队列内容
                tasks1.put(os.popen(&apos;id&apos;).read())
                print(&apos;Worker %s got task %s&apos; % (n, task))
                gevent.sleep(0)           # 放弃当前任务

        def worker2(name):
            try:
                while True:
                    task = tasks1.get(timeout=2)
                    print &apos;获取后释放:%s&apos; % task
                    gevent.sleep(0)
            except Empty:                 # 等待超时报错完成
                print(&apos;Quitting time!&apos;)

        gevent.spawn(boss).join()         # 执行单次协程任务

        pool = Pool(5)                    # 协程池大小
        pool.map(worker1, xrange(0,20))   # 通过map方法把多个任务分发给池中的5个协程

        gevent.joinall([                  # 同时执行多个协程任务
            gevent.spawn(worker2, &apos;steve&apos;),
            gevent.spawn(worker2, &apos;john&apos;),
            gevent.spawn(worker2, &apos;nancy&apos;),
        ])</code></pre><p>9 框架</p>
<pre><code>flask           [微型网络开发框架]

    # http://dormousehole.readthedocs.org/en/latest/
    # http://www.pythonhosted.org/Flask-Bootstrap/basic-usage.html#templates
    # html放在 ./templates/   js放在 ./static/

    #pip install Flask-Login
    #pip install Flask-OpenID
    #pip install Flask-WTF
    #pip install flask-bootstrap
    #pip install flask-sqlalchemy
    #pip install flask-script
    #pip install flask-migrate

    request.args.get(&apos;page&apos;, 1)          # 获取参数 ?page=1
    request.json                         # 获取传递的整个json数据
    request.form.get(&quot;host&quot;,&apos;127&apos;)       # 获取表单值
    request.form.getlist(&apos;client&apos;)       # 获取表单列表

    简单实例 # 接收数据和展示

        import MySQLdb as mysql
        from flask import Flask, request

        app = Flask(__name__)
        db.autocommit(True)
        c = db.cursor()

        &quot;&quot;&quot;
        CREATE TABLE `statusinfo` (
          `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
          `hostname` varchar(32) NOT NULL,
          `load` float(10) NOT NULL DEFAULT 0.00,
          `time` int(15) NOT NULL,
          `memtotal` int(15) NOT NULL,
          `memusage` int(15) NOT NULL,
          `memfree` int(15) NOT NULL,
          PRIMARY KEY (`id`)
        ) ENGINE=InnoDB AUTO_INCREMENT=161 DEFAULT CHARSET=utf8;
        &quot;&quot;&quot;

        @app.route(&quot;/collect&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])
        def collect():
            sql = &quot;&quot;
            if request.method == &quot;POST&quot;:
                data = request.json                      # 获取传递的json
                hostname = data[&quot;Host&quot;]
                load = data[&quot;LoadAvg&quot;]
                time = data[&quot;Time&quot;]
                memtotal = data[&quot;MemTotal&quot;]
                memusage = data[&quot;MemUsage&quot;]
                memfree = data[&quot;MemFree&quot;]

                try:
                    sql = &quot;INSERT INTO `statusinfo` (`hostname`,`load`,`time`,`memtotal`,`memusage`,`memfree`) VALUES(&apos;%s&apos;, %s, %s, %s, %s, %s);&quot; % (hostname, load,time,memtotal,memusage,memfree)
                    ret = c.execute(sql)
                    return &apos;ok&apos;
                except mysql.IntegrityError:
                    return &apos;errer&apos;

        @app.route(&quot;/show&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])
        def show():
            try:
                hostname = request.form.get(&quot;hostname&quot;)     # 获取表单方式的变量值
                sql = &quot;SELECT `load` FROM `statusinfo` WHERE hostname = &apos;%s&apos;;&quot; % (hostname)
                c.execute(sql)
                ones = c.fetchall()
                return render_template(&quot;sysstatus.html&quot;, data=ones, sql = sql)
            except:
                print &apos;hostname null&apos;

        from flask import render_template
        @app.route(&quot;/xxx/&lt;name&gt;&quot;)
        def hello_xx(name):
            return render_template(&quot;sysstatus.html&quot;, name=&apos;teach&apos;)

        if __name__ == &quot;__main__&quot;:
            app.run(host=&quot;0.0.0.0&quot;, port=50000, debug=True)

    Flask-SQLAlchemy

        http://www.pythondoc.com/flask-sqlalchemy/queries.html#id2
        http://docs.jinkan.org/docs/flask-sqlalchemy/models.html#id2
        https://www.cnblogs.com/mosson/p/6257147.html

        db.create_all()   # 创建表

        增加
            admin = User(&apos;admin&apos;, &apos;admin@example.com&apos;)
            db.session.add(admin)
            db.session.add(guest)
            db.session.commit()

        查询
            # 返回数组
            users = User.query.all()
            # 条件过滤 返回一个对象  不存在返回 返回none  像python传参数
            peter = User.query.filter_by(username = &apos;peter&apos;).first()
            # 条件过滤 像sql 可使用 &gt;&lt;
            peter = User.query.filter(username == &apos;peter&apos;).first()
            # 获取指定列的值
            print peter.username
            # 复杂查询 返回列表对象
            User.query.filter(User.email.endswith(&apos;@example.com&apos;)).all()
            # 对查询结果按指定列排序
            User.query.order_by(User.username)
            # 取前面的指定条数
            User.query.limit(1).all()
            # 通过主键来获取对象
            User.query.get(1)
            # 通配查询 ilike 忽略大小写
            User.query.filter(User.username.ilike(&apos;online_%&apos;)).all()
            User.query.filter(User.username.notilike(&apos;online_%&apos;)).all()

        删除
            user = User.query.get(id)
            db.session.delete(user)
            db.session.commit()
            User.query.filter_by(id=123).delete()
            User.query.filter(User.id == 123).delete()

        改
            db.session.query(Users).filter(Users.id &gt; 2).update({&quot;name&quot; : &quot;099&quot;})
            db.session.commit()


            q = db.session.query(Toner)
            q = q.filter(Toner.toner_id==1)
            record = q.one()
            record.toner_color = &apos;Azure Radiance&apos;
            db.session.flush()

        连表
            ret = session.query(Users, Favor).filter(Users.id == Favor.nid).all()
            ret = session.query(Person).join(Favor).all()
            ret = session.query(Person).join(Favor, isouter=True).all()

        通配符
            ret = session.query(Users).filter(Users.name.like(&apos;e%&apos;)).all()
            ret = session.query(Users).filter(~Users.name.like(&apos;e%&apos;)).all()

        排序
            ret = session.query(Users).order_by(Users.name).all()                          # 正序
            ret = session.query(Users).order_by(Users.name.desc()).all()                   # 倒序
            ret = session.query(Users).order_by(Users.name.desc(), Users.id.asc()).all()



twisted         [非阻塞异步服务器框架]

    # 较老 推荐使用 协程框架 或 微线程框架
    # 用来进行网络服务和应用程序的编程。虽然 Twisted Matrix 中有大量松散耦合的模块化组件，但该框架的中心概念还是非阻塞异步服务器这一思想。对于习惯于线程技术或分叉服务器的开发人员来说，这是一种新颖的编程风格，但它却能在繁重负载的情况下带来极高的效率。
    pip install twisted

    from twisted.internet import protocol, reactor, endpoints

    class Echo(protocol.Protocol):
        def dataReceived(self, data):
            self.transport.write(data)
    class EchoFactory(protocol.Factory):
        dDescribeInstanceStatusef buildProtocol(self, addr):
            return Echo()

    endpoints.serverFromString(reactor, &quot;tcp:1234&quot;).listen(EchoFactory())
    reactor.run()

    服务端

        #!/usr/bin/env python

        from twisted.application import service, internet
        from txjsonrpc.netstring import jsonrpc

        class Example(jsonrpc.JSONRPC):
            &quot;&quot;&quot;An example object to be published.&quot;&quot;&quot;
            def jsonrpc_echo(self,  x):
                &quot;&quot;&quot;Return all passed args.&quot;&quot;&quot;
                return x
            def jsonrpc_add(self, a, b):
                &quot;&quot;&quot;Return sum of arguments.&quot;&quot;&quot;
                print &quot;add&quot;, a, b
                return a + b

        factory = jsonrpc.RPCFactory(Example())
        application = service.Application(&quot;Example JSON-RPC Server&quot;)
        jsonrpcServer = internet.TCPServer(7080, factory)
        jsonrpcServer.setServiceParent(application)


    客户端
        #!/usr/bin/env python

        import os
        import sys
        sys.path.insert(0, os.getcwd())
        from twisted.internet import reactor
        from txjsonrpc.netstring.jsonrpc import Proxy

        def printValue(value):
            print &quot;Result: %s&quot; % str(value)
            reactor.stop()

        def printError(error):
            print &apos;error&apos;, error
            reactor.stop()

        proxy = Proxy(&apos;127.0.0.1&apos;, 7080)
        proxy.callRemote(&apos;add&apos;, 3, 5).addCallbacks(printValue, printError)
        reactor.run()

Celery          [分布式任务队列]

    # http://docs.jinkan.org/docs/celery/getting-started/introduction.html
    pip install -U Celery

tornado         [极轻量级Web服务器框架]

    # 高可伸缩性和epoll非阻塞IO,响应快速,可处理数千并发连接,特别适用用于实时的Web服务 底层是gevent协程
    # http://www.tornadoweb.cn/documentation
    # http://old.sebug.net/paper/books/tornado/#_2
    # http://demo.pythoner.com/itt2zh/ch5.html
    # 非阻塞方式生成子进程
    # https://github.com/vukasin/tornado-subprocess

    pip install tornado

    self.get_argument()           # 方法来获取查询字符串参数，以及解析 POST 的内容
    self.request.arguments        # 所有的 GET 或 POST 的参数
    self.request.files            # 所有通过 multipart/form-data POST 请求上传的文件
    self.request.path             # 请求的路径（ ? 之前的所有内容）
    self.request.headers          # 请求的开头信息
    callback                      # 执行完成后执行回调函数

    @tornado.web.asynchronous     # 非阻塞异步装饰器
    self.finish()                 # 使用非阻塞异步 必须调用 self.finish() 已完成 HTTTP 请求
    # 异步 HTTP 客户端 两种模式 默认 SimpleAsyncHTTPClient  如果要修改为 CurlAsyncHTTPClient
    AsyncHTTPClient.configure(&apos;tornado.curl_httpclient.CurlAsyncHTTPClient&apos;)


    import tornado.ioloop
    import tornado.web
    import tornado.httpclient
    import json


    class MainHandler(tornado.web.RequestHandler):
        def get(self):
            self.write(&quot;Hello, world&quot;)

        def post(self):
            self.set_header(&quot;Content-Type&quot;, &quot;text/plain&quot;)
            self.write(&quot;You wrote &quot; + self.get_argument(&quot;message&quot;))

    class Template(tornado.web.RequestHandler):
        def get(self):
            items = [&quot;Item 1&quot;, &quot;Item 2&quot;, &quot;Item 3&quot;]
            self.render(&quot;template.html&quot;, title=&quot;My title&quot;, items=items)

    class urlhttp(tornado.web.RequestHandler):
        @tornado.web.asynchronous
        def get(self):
            http = tornado.httpclient.AsyncHTTPClient()
            http.fetch(&quot;http://friendfeed-api.com/v2/feed/bret&quot;, callback=self.on_response)

        def on_response(self, response):
            if response.error: raise tornado.web.HTTPError(500)
            jsondata = tornado.escape.json_decode(response.body)
            print type(jsondata)
            self.write(json.dumps(jsondata))
            self.finish()

    class StoryHandler(tornado.web.RequestHandler):
        def get(self, story_id):
            self.write(&quot;You requested the story &quot; + story_id)

    def make_app():
        return tornado.web.Application([
            (r&quot;/&quot;, MainHandler),
            (r&quot;/template&quot;, Template),
            (r&quot;/story/([0-9]+)&quot;, StoryHandler),
            (r&quot;/tapi&quot;, urlhttp),
        ])

    if __name__ == &quot;__main__&quot;:
        app = make_app()
        app.listen(8888)
        tornado.ioloop.IOLoop.current().start()


Scrapy          [web抓取框架]

    # Python开发的一个快速,高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。
    pip install scrapy

    from scrapy import Spider, Item, Field

    class Post(Item):
        title = Field()

    class BlogSpider(Spider):
        name, start_urls = &apos;blogspider&apos;, [&apos;http://blog.scrapinghub.com&apos;]

        def parse(self, response):
            return [Post(title=e.extract()) for e in response.css(&quot;h2 a::text&quot;)]

    scrapy runspider myspider.py

django          [重量级web框架]

bottle          [轻量级的Web框架]

stackless       [增强版python]

    微线程扩展，是一种低开销、轻量级的便利工具  避免传统线程所带来的性能与复杂度问题

greenlet        [微线程/协程框架]

    # 更加原始的微线程的概念,没有调度,或者叫做协程。这在你需要控制你的代码时很有用。你可以自己构造微线程的 调度器；也可以使用&quot;greenlet&quot;实现高级的控制流。例如可以重新创建构造器；不同于Python的构造器，我们的构造器可以嵌套的调用函数，而被嵌套的函数也可以 yield 一个值。
    pip install greenlet

asyncio         [异步I/O协同]

    # https://docs.python.org/3/library/asyncio.html
    需要python3.4+
    asyncio: 协同程序和事件循环。协同程序像是方法，但是它们可以在代码中的特定点暂停和继续。当在等待一个IO（比如一个HTTP请求），同时执行另一个请求的时候，可以用来暂停一个协同程序。我们使用关键字yield from来设定一个状态，表明我们需要一个协同程序的返回值。而事件循环则被用来安排协同程序的执行。</code></pre><p>10例子</p>
<pre><code>小算法

    斐波那契
        #将函数结果作为列表可用于循环
        def fab(max):
        n, a, b = 0, 0, 1
        while n &lt; max:
            yield b
            a, b = b, a + b
            n = n + 1
        for n in fab(5):
            print n

    乘法口诀

        #!/usr/bin/python
        for i in range(1,10):
            for j in range(1,i+1):
                print j,&apos;*&apos;,i,&apos;=&apos;,j*i,
            else:
                print &apos;&apos;

    最小公倍数

        # 1-70的最小公倍数
        def c(m,n):
                a1=m
                b1=n
                r=n%m
                while r!=0:
                        n=m
                        m=r
                        r=n%m
                return (a1*b1)/m
        d=1
        for i in range(3,71,2):
                d = c(d,i)
        print d

    排序算法

        插入排序
            def insertion_sort(sort_list):
                iter_len = len(sort_list)
                if iter_len &lt; 2:
                    return sort_list
                for i in range(1, iter_len):
                    key = sort_list[i]
                    j = i - 1
                    while j&gt;=0 and sort_list[j]&gt;key:
                        sort_list[j+1] = sort_list[j]
                        j -= 1
                    sort_list[j+1] = key
                return sort_list

        选择排序
            def selection_sort(sort_list):
                iter_len = len(sort_list)
                if iter_len &lt; 2:
                    return sort_list
                for i in range(iter_len-1):
                    smallest = sort_list[i]
                    location = i
                    for j in range(i, iter_len):
                        if sort_list[j] &lt; smallest:
                            smallest = sort_list[j]
                            location = j
                    if i != location:
                        sort_list[i], sort_list[location] = sort_list[location], sort_list[i]
                return sort_list

        冒泡排序
            def bubblesort(numbers):
                for j in range(len(numbers)-1,-1,-1):
                    for i in range(j):
                        if numbers[i]&gt;numbers[i+1]:
                            numbers[i],numbers[i+1] = numbers[i+1],numbers[i]
                        print(i,j)
                        print(numbers)

        快速排序

            # 先从数列中取出一个数作为基准数。
            # 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。
            # 再对左右区间重复第二步，直到各区间只有一个数。
            #!/usr/bin/python
            # -*- coding: utf-8 -*-

            def sub_sort(array,low,high):
                key = array[low]
                while low &lt; high:
                    while low &lt; high and array[high] &gt;= key:
                        high -= 1
                    while low &lt; high and array[high] &lt; key:
                        array[low] = array[high]
                        low += 1
                        array[high] = array[low]
                array[low] = key
                return low

            def quick_sort(array,low,high):
                 if low &lt; high:
                    key_index = sub_sort(array,low,high)
                    quick_sort(array,low,key_index)
                    quick_sort(array,key_index+1,high)

            if __name__ == &apos;__main__&apos;:
                array = [8,10,9,6,4,16,5,13,26,18,2,45,34,23,1,7,3]
                print array
                quick_sort(array,0,len(array)-1)
                print array

    二分算法

        #python 2f.py 123456789 4
        # list(&apos;123456789&apos;)  =  [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;]
        #!/usr/bin/env python
        import sys

        def search2(a,m):
            low = 0
            high = len(a) - 1
            while(low &lt;= high):
                mid = (low + high)/2
                midval = a[mid]

                if midval &lt; m:
                    low = mid + 1
                elif midval &gt; m:
                    high = mid - 1
                else:
                    print mid
                    return mid
            print -1
            return -1

        if __name__ == &quot;__main__&quot;:
            a = [int(i) for i in list(sys.argv[1])]
            m = int(sys.argv[2])
            search2(a,m)

    全排序

        def Mideng(li):
            if(type(li)!=list):
                return
            if(len(li)==1):
                return [li]
            result=[]
            for i in range(0,len(li[:])):
                bak=li[:]
                head=bak.pop(i)
                for j in Mideng(bak):
                    j.insert(0,head)
                    result.append(j)
            return result
        def MM(n):
            if(type(n)!=int or n&lt;2):
                return
            return Mideng(list(range(1,n)))

        MM(6)

嵌套复杂排序

    字典排序

        按照键值(value)排序
            # a = {&apos;a&apos;: &apos;China&apos;, &apos;c&apos;: &apos;USA&apos;, &apos;b&apos;: &apos;Russia&apos;, &apos;d&apos;: &apos;Canada&apos;}
            b = sorted(a.items(), key=lambda x: x[1], reverse=True)
            #[(&apos;c&apos;, &apos;USA&apos;), (&apos;b&apos;, &apos;Russia&apos;), (&apos;a&apos;, &apos;China&apos;), (&apos;d&apos;, &apos;Canada&apos;)]

        按照键名(key)排序
            #a = {&apos;a&apos;: &apos;China&apos;, &apos;c&apos;: &apos;USA&apos;, &apos;b&apos;: &apos;Russia&apos;, &apos;d&apos;: &apos;Canada&apos;}
            b = sorted(a.items(), key=lambda x: x[0], reverse=True)
            #[(&apos;d&apos;, &apos;Canada&apos;), (&apos;c&apos;, &apos;USA&apos;), (&apos;b&apos;, &apos;Russia&apos;), (&apos;a&apos;, &apos;China&apos;)]

        嵌套字典, 按照字典键名(key)排序
            #a = {&apos;a&apos;: {&apos;b&apos;:  &apos;China&apos;}, &apos;c&apos;: {&apos;d&apos;: &apos;USA&apos;}, &apos;b&apos;: {&apos;c&apos;: &apos;Russia&apos;}, &apos;d&apos;: {&apos;a&apos;: &apos;Canada&apos;}}
            b = sorted(a.items(), key=lambda x: x[1], reverse=True)
            #[(&apos;c&apos;, {&apos;d&apos;: &apos;USA&apos;}), (&apos;b&apos;, {&apos;c&apos;: &apos;Russia&apos;}), (&apos;a&apos;, {&apos;b&apos;: &apos;China&apos;}), (&apos;d&apos;, {&apos;a&apos;: &apos;Canada&apos;})]

        嵌套列表, 针对列表第一个元素排序( 其实直接写 x: x[1] 就是按照第一个值排序. )
            #a = {&apos;a&apos;: [1, 3], &apos;c&apos;: [3, 4], &apos;b&apos;: [0, 2], &apos;d&apos;: [2, 1]}
            b = sorted(a.items(), key=lambda x: x[1][0], reverse=True)
            #[(&apos;c&apos;, [3, 4]), (&apos;d&apos;, [2, 1]), (&apos;a&apos;, [1, 3]), (&apos;b&apos;, [0, 2])]

        嵌套列表, 按照列表其他元素排序  只需要修改列表对应的下标
            # a = {&apos;a&apos;: [1, 3], &apos;c&apos;: [3, 4], &apos;b&apos;: [0, 2], &apos;d&apos;: [2, 1]}
            b = sorted(a.items(), key=lambda x: x[1][1], reverse=True)
            # [(&apos;c&apos;, [3, 4]), (&apos;a&apos;, [1, 3]), (&apos;b&apos;, [0, 2]), (&apos;d&apos;, [2, 1])]

        # 总结:  此处使用lambda方法, x: x[1][1] 就可以看做是在访问字典的值, 想要按照哪个数值排序, 用相应的坐标对应即可, 但当字典过于复杂后, 应该选择用元组存储, 简化排序过程.


    列表排序

        1: 按照字母排序
            # a = [&apos;USA&apos;, &apos;China&apos;, &apos;Canada&apos;, &apos;Russia&apos;]
            a.sort(reverse=True)
            # [&apos;USA&apos;, &apos;Russia&apos;, &apos;China&apos;, &apos;Canada&apos;]

        2: 嵌套列表的排序, 按照子列表的其他值排序雷系, 修改x[0] 这里的下标即可
            # a = [[&apos;USA&apos;, &apos;b&apos;], [&apos;China&apos;, &apos;c&apos;], [&apos;Canada&apos;, &apos;d&apos;], [&apos;Russia&apos;, &apos;a&apos;]]
            a.sort(key=lambda x: x[0], reverse=True)
            # [[&apos;USA&apos;, &apos;b&apos;], [&apos;Russia&apos;, &apos;a&apos;], [&apos;China&apos;, &apos;c&apos;], [&apos;Canada&apos;, &apos;d&apos;]]

        3: 嵌套字典, 按照字典值(value) 排序
            # a = [{&apos;letter&apos;: &apos;b&apos;}, {&apos;letter&apos;: &apos;c&apos;}, {&apos;letter&apos;: &apos;d&apos;}, {&apos;letter&apos;: &apos;a&apos;}]
            a.sort(key=lambda x: x[&apos;letter&apos;], reverse=True)
            # [{&apos;letter&apos;: &apos;d&apos;}, {&apos;letter&apos;: &apos;c&apos;}, {&apos;letter&apos;: &apos;b&apos;}, {&apos;letter&apos;: &apos;a&apos;}]

        4: 当字典值也是字典时, 这时候会优先按照键名排序, 再按照键值排序. 例子如下
            # a = [{&apos;letter&apos;: {&apos;a&apos;: &apos;b&apos;}}, {&apos;letter&apos;: {&apos;a&apos;: &apos;c&apos;}}, {&apos;letter&apos;: {&apos;a&apos;: &apos;d&apos;}}, {&apos;letter&apos;: {&apos;a&apos;: &apos;a&apos;}}]
            a.sort(key=lambda x: x[&apos;letter&apos;], reverse=True)
            # [{&apos;letter&apos;: {&apos;a&apos;: &apos;d&apos;}}, {&apos;letter&apos;: {&apos;a&apos;: &apos;c&apos;}}, {&apos;letter&apos;: {&apos;a&apos;: &apos;b&apos;}}, {&apos;letter&apos;: {&apos;a&apos;: &apos;a&apos;}}]

        方法2:
            # a = [{&apos;letter&apos;: {&apos;a&apos;: &apos;b&apos;}}, {&apos;letter&apos;: {&apos;b&apos;: &apos;c&apos;}}, {&apos;letter&apos;: {&apos;c&apos;: &apos;d&apos;}}, {&apos;letter&apos;: {&apos;d&apos;: &apos;a&apos;}}]
            a.sort(key=lambda x: x[&apos;letter&apos;], reverse=True)
            #[{&apos;letter&apos;: {&apos;d&apos;: &apos;a&apos;}}, {&apos;letter&apos;: {&apos;c&apos;: &apos;d&apos;}}, {&apos;letter&apos;: {&apos;b&apos;: &apos;c&apos;}}, {&apos;letter&apos;: {&apos;a&apos;: &apos;b&apos;}}]


1000以内是3或者是5的倍数的值的和

    sum([ num for num in range(1, 1000) if num % 3 == 0 or num % 5 == 0 ])

打印如下列表
    1
    2 1
    3 2 1
    4 3 2 1
    5 4 3 2 1
    6 5 4 3 2 1

    #!/usr/local/python

    i=1
    while i &lt; 7:
        a = &quot;&quot;
        n=1
        while n &lt;= i:
            a = &quot;%s %s&quot; %(n, a)
            n = n + 1

        print a
        i = i + 1

将字典中所有time去掉

    a={&apos;version01&apos;: {&apos;nba&apos;: {&apos;timenba&apos;: &apos;valuesasdfasdf&apos;, &apos;nbanbac&apos;: &apos;vtimefasdf&apos;, &apos;userasdf&apos;: &apos;vtimasdf&apos;}}}
    eval(str(a).replace(&quot;time&quot;,&quot;&quot;))


阿里云oss

    https://help.aliyun.com/document_detail/32027.html?spm=5176.doc32026.6.674.AXf7Lw
    pip install oss2

    # -*- coding: utf-8 -*-
    import oss2

    auth = oss2.Auth(&apos;AccessKeyId&apos;, &apos;AccessKeySecret&apos;)
    # 注意内外网域名 不带bucket
    service = oss2.Service(auth, &apos;oss-cn-shanghai-internal.aliyuncs.com&apos;)

    print([b.name for b in oss2.BucketIterator(service)])        # 查看存在的bucket

    bucket = oss2.Bucket(auth, &apos;http://oss-cn-shanghai-internal.aliyuncs.com&apos;, &apos;ec-share&apos;)
    # bucket.create_bucket(oss2.models.BUCKET_ACL_PRIVATE)       # 创建bucket
    bucket.put_object_from_file(&apos;remote.txt&apos;,&apos;/tmp/local.txt&apos;)   # 上传文件
    bucket.get_object_to_file(&apos;remote.txt&apos;, &apos;local-backup.txt&apos;)  # 下载文件
    bucket.delete_object(&apos;remote.txt&apos;)                           # 删除文件


阿里云ecs
    https://help.aliyun.com/document_detail/67117.html?spm=a2c4g.11186623.6.543.390360e41Cfpqm
    pip install aliyun-python-sdk-core     # 安装阿里云SDK核心库
    pip install aliyun-python-sdk-ecs      # 安装管理ECS的库

    from aliyunsdkcore.client import AcsClient
    from aliyunsdkcore.acs_exception.exceptions import ClientException
    from aliyunsdkcore.acs_exception.exceptions import ServerException
    from aliyunsdkecs.request.v20140526 import DescribeInstancesRequest
    from aliyunsdkecs.request.v20140526 import StopInstanceRequest
    client = AcsClient(
       &quot;your-access-key-id&quot;, 
       &quot;your-access-key-secret&quot;,
       &quot;your-region-id&quot;
    );
    request = DescribeInstancesRequest.DescribeInstancesRequest()
    request.set_PageSize(10)
    try:
        response = client.do_action_with_exception(request)
        print response
    except ServerException as e:
        print e
    except ClientException as e:
    print e


    # 使用CommonRequest的方式调用ECS的 DescribeInstanceStatus 接口

    from aliyunsdkcore.client import AcsClient
    from aliyunsdkcore.request import CommonRequest
    client = AcsClient(&apos;your_access_key_id&apos;, &apos;your_access_key_secret&apos;, &apos;your_region_id&apos;)
    request = CommonRequest()
    request.set_domain(&apos;ecs.aliyuncs.com&apos;)
    request.set_version(&apos;2014-05-26&apos;)
    request.set_action_name(&apos;DescribeInstanceStatus&apos;)
    request.add_query_param(&apos;PageNumber&apos;, &apos;1&apos;)
    request.add_query_param(&apos;PageSize&apos;, &apos;30&apos;)
    request.add_query_param(&apos;ZoneId&apos;, &apos;cn-shanghai-d&apos;)
    response = client.do_action_with_exception(request)


    # 接口列表
    https://help.aliyun.com/document_detail/25506.html?spm=a2c4g.11186623.6.1084.2f672eafMskx7S
    # 调用DescribeInstances查询一台或多台实例的详细信息
    DescribeInstances
    # 调用CreateInstance创建一台ECS实例
    CreateInstance
    # 调用StartInstance启动一台实例
    StartInstance
    # 调用StopInstance停止运行一台实例
    StopInstance
    # 调用DescribeInstanceStatus获取一台或多台ECS实例的状态信息
    DescribeInstanceStatus


    # 创建ecs, CreateInstance, stop状态
    # 参数列表
    # https://help.aliyun.com/document_detail/25499.html?spm=a2c4g.11186623.6.1095.4347431djUtw2v

    from aliyunsdkcore.client import AcsClient
    from aliyunsdkcore.request import CommonRequest
    client = AcsClient(&apos;LTAIzeBZre&apos;, &apos;fLJOBweE8qHKxrEOnc2FIF&apos;, &apos;cn-shanghai&apos;)
    request = CommonRequest()
    request.set_domain(&apos;ecs.aliyuncs.com&apos;)
    request.set_version(&apos;2014-05-26&apos;)
    request.set_action_name(&apos;CreateInstance&apos;)

    request.add_query_param(&apos;ImageId&apos;, &apos;m-uf67jei1pul0xpfsfpfv&apos;)
    request.add_query_param(&apos;InstanceType&apos;, &apos;ecs.c5.large&apos;)
    request.add_query_param(&apos;RegionId&apos;, &apos;cn-shanghai&apos;)
    request.add_query_param(&apos;ZoneId&apos;, &apos;cn-shanghai-f&apos;)
    request.add_query_param(&apos;SecurityGroupId&apos;, &apos;sg-uf6i53pjsi11yuyrwyqs&apos;)
    request.add_query_param(&apos;VSwitchId&apos;, &apos;vsw-uf630eqh0edoe9n3ig7lz&apos;)
    request.add_query_param(&apos;Period&apos;, &apos;1&apos;)
    request.add_query_param(&apos;InstanceChargeType&apos;, &apos;PrePaid&apos;)
    request.add_query_param(&apos;AutoRenew&apos;, &apos;true&apos;)
    request.add_query_param(&apos;AutoRenewPeriod&apos;, &apos;1&apos;)
    request.add_query_param(&apos;InstanceName&apos;, &apos;xuesong-test1&apos;)
    request.add_query_param(&apos;HostName&apos;, &apos;xuesong-test1&apos;)
    request.add_query_param(&apos;Password&apos;, &apos;azuDa9nee6aiHaey&apos;)
    request.add_query_param(&apos;SystemDisk.Size&apos;, &apos;200&apos;)
    request.add_query_param(&apos;SystemDisk.Category&apos;, &apos;cloud_efficiency&apos;)
    request.add_query_param(&apos;SystemDisk.DiskName&apos;, &apos;xuesong-test1&apos;)

    response = client.do_action_with_exception(request)
    # InstanceId               # 实例ID，是访问实例的唯一标识
    # RequestId                # 无论调用接口成功与否，都会返回请求ID

    # 启动ecs   StartInstance
    from aliyunsdkcore.client import AcsClient
    from aliyunsdkcore.request import CommonRequest
    client = AcsClient(&apos;LTAIzeBZre&apos;, &apos;fLJOBweE8qHKxrEOnc2FIF&apos;, &apos;cn-shanghai&apos;)
    request = CommonRequest()
    request.set_domain(&apos;ecs.aliyuncs.com&apos;)
    request.set_version(&apos;2014-05-26&apos;)
    request.set_action_name(&apos;StartInstance&apos;)

    request.add_query_param(&apos;InstanceId&apos;, &apos;i-uf69e821lkybxke6yyno&apos;)
    response = client.do_action_with_exception(request)


    # 查询ecs信息 DescribeInstances
    from aliyunsdkcore.client import AcsClient
    from aliyunsdkcore.request import CommonRequest
    import json

    client = AcsClient(&apos;LTAIzeBZre&apos;, &apos;fLJOBweE8qHKxrEOnc2FIF&apos;, &apos;cn-shanghai&apos;)
    request = CommonRequest()
    request.set_domain(&apos;ecs.aliyuncs.com&apos;)
    request.set_version(&apos;2014-05-26&apos;)
    request.set_action_name(&apos;DescribeInstances&apos;)

    request.add_query_param(&apos;InstanceIds&apos;, [&apos;i-uf69e821lkybxke6yyno&apos;])
    response = client.do_action_with_exception(request)
    jresponse = json.loads(response)
    ip = jresponse[&apos;Instances&apos;][&apos;Instance&apos;][0][&apos;NetworkInterfaces&apos;][&apos;NetworkInterface&apos;][0][&apos;PrimaryIpAddress&apos;]
    status = jresponse[&apos;Instances&apos;][&apos;Instance&apos;][0][&apos;Status&apos;]
    # Stopped  Stopping  Starting  Running 


    # 停止ecs StopInstance
    from aliyunsdkcore.client import AcsClient
    from aliyunsdkcore.request import CommonRequest

    client = AcsClient(&apos;LTAIzeBZre&apos;, &apos;fLJOBweE8qHKxrEOnc2FIF&apos;, &apos;cn-shanghai&apos;)
    request = CommonRequest()
    request.set_domain(&apos;ecs.aliyuncs.com&apos;)
    request.set_version(&apos;2014-05-26&apos;)
    request.set_action_name(&apos;StopInstance&apos;)

    request.add_query_param(&apos;InstanceId&apos;, &apos;i-uf69e821lkybxke6yyno&apos;)
    response = client.do_action_with_exception(request)



    # 删除ecs DeleteInstance  释放一台按量付费实例或者到期的预付费（包年包月）实例
    from aliyunsdkcore.client import AcsClient
    from aliyunsdkcore.request import CommonRequest

    client = AcsClient(&apos;LTAIzeBZre&apos;, &apos;fLJOBweE8qHKxrEOnc2FIF&apos;, &apos;cn-shanghai&apos;)
    request = CommonRequest()
    request.set_domain(&apos;ecs.aliyuncs.com&apos;)
    request.set_version(&apos;2014-05-26&apos;)
    request.set_action_name(&apos;DeleteInstance&apos;)

    request.add_query_param(&apos;InstanceId&apos;, &apos;i-uf69e821lkybxke6yyno&apos;)
    request.add_query_param(&apos;Force&apos;, &apos;true&apos;)

    response = client.do_action_with_exception(request)



PIL图像处理

    import Image
    im = Image.open(&quot;j.jpg&quot;)            # 打开图片
    print im.format, im.size, im.mode   # 打印图像格式、像素宽和高、模式
    # JPEG (440, 330) RGB
    im.show()                           # 显示最新加载图像
    box = (100, 100, 200, 200)
    region = im.crop(box)               # 从图像中提取出某个矩形大小的图像

图片等比缩小

    # -*- coding: cp936 -*-
    import Image
    import glob, os

    #图片批处理
    def timage():
        for files in glob.glob(&apos;D:\\1\\*.JPG&apos;):
            filepath,filename = os.path.split(files)
            filterame,exts = os.path.splitext(filename)
            #输出路径
            opfile = r&apos;D:\\22\\&apos;
            #判断opfile是否存在，不存在则创建
            if (os.path.isdir(opfile)==False):
                os.mkdir(opfile)
            im = Image.open(files)
            w,h = im.size
            #im_ss = im.resize((400,400))
            #im_ss = im.convert(&apos;P&apos;)
            im_ss = im.resize((int(w*0.12), int(h*0.12)))
            im_ss.save(opfile+filterame+&apos;.jpg&apos;)

    if __name__==&apos;__main__&apos;:
        timage()

取系统返回值赋给序列

    cmd = os.popen(&quot;df -Ph|awk &apos;NR!=1{print $5}&apos;&quot;).readlines();
    cmd = os.popen(&apos;df -h&apos;).read().split(&apos;\n&apos;)
    cmd = os.popen(&apos;lo 2&gt;&amp;1&apos;).read()

    #取磁盘使用空间
    import commands
    df = commands.getoutput(&quot;df -hP&quot;)
    [ x.split()[4] for x in df.split(&quot;\n&quot;) ]
    [ (x.split()[0],x.split()[4]) for x in df.split(&quot;\n&quot;) if x.split()[4].endswith(&quot;%&quot;) ]

切片获取星星

    def getRating(rating):
        return &apos;★★★★★☆☆☆☆☆&apos;.decode(&apos;utf8&apos;)[5-rating:10-rating]
    print getRating(1)
    print getRating(3)

打印表格

    map = [[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],
           [&quot;d&quot;,&quot;e&quot;,&quot;f&quot;],
           [&quot;g&quot;,&quot;h&quot;,&quot;i&quot;]]
    def print_board():
        for i in range(0,3):
            for j in range(0,3):
                print &quot;|&quot;,map[i][j],
                #if j != 2:
            print &apos;|&apos;


井字游戏

    #!/usr/bin/python
    # http://www.admin10000.com/document/2506.html
    def print_board():
        for i in range(0,3):
            for j in range(0,3):
                print map[2-i][j],
                if j != 2:
                    print &quot;|&quot;,
            print &quot;&quot;

    def check_done():
        for i in range(0,3):
            if map[i][0] == map[i][1] == map[i][2] != &quot; &quot; \
            or map[0][i] == map[1][i] == map[2][i] != &quot; &quot;:
                print turn, &quot;won!!!&quot;
                return True

        if map[0][0] == map[1][1] == map[2][2] != &quot; &quot; \
        or map[0][2] == map[1][1] == map[2][0] != &quot; &quot;:
            print turn, &quot;won!!!&quot;
            return True

        if &quot; &quot; not in map[0] and &quot; &quot; not in map[1] and &quot; &quot; not in map[2]:
            print &quot;Draw&quot;
            return True

        return False

    turn = &quot;X&quot;
    map = [[&quot; &quot;,&quot; &quot;,&quot; &quot;],
           [&quot; &quot;,&quot; &quot;,&quot; &quot;],
           [&quot; &quot;,&quot; &quot;,&quot; &quot;]]
    done = False

    while done != True:
        print_board()

        print turn, &quot;&apos;s turn&quot;
        print

        moved = False
        while moved != True:
            print &quot;Please select position by typing in a number between 1 and 9, see below for which number that is which position...&quot;
            print &quot;7|8|9&quot;
            print &quot;4|5|6&quot;
            print &quot;1|2|3&quot;
            print

            try:
                pos = input(&quot;Select: &quot;)
                if pos &lt;=9 and pos &gt;=1:
                    Y = pos/3
                    X = pos%3
                    if X != 0:
                        X -=1
                    else:
                         X = 2
                         Y -=1

                    if map[Y][X] == &quot; &quot;:
                        map[Y][X] = turn
                        moved = True
                        done = check_done()

                        if done == False:
                            if turn == &quot;X&quot;:
                                turn = &quot;O&quot;
                            else:
                                turn = &quot;X&quot;

            except:
                print &quot;You need to add a numeric value&quot;

网段划分

    题目
        192.168.1
        192.168.3
        192.168.2
        172.16.3
        192.16.1
        192.16.2
        192.16.3
        10.0.4

        输出结果：
        192.16.1-192.16.3
        192.168.1-192.168.3
        172.16.3
        10.0.4

    答案
        #!/usr/bin/python

        f = file(&apos;a.txt&apos;)
        c = f.readlines()
        dic={}

        for i in c:
            a=i.strip().split(&apos;.&apos;)
            if a[0]+&apos;.&apos;+a[1] in dic.keys():
                key=dic[&quot;%s.%s&quot; %(a[0],a[1])]
            else:
                key=[]
            key.append(a[2])
            dic[a[0]+&apos;.&apos;+a[1]]=sorted(key)

        for x,y in dic.items():
            if y[0] == y[-1]:
                print &apos;%s.%s&apos; %(x,y[0])
            else:
                print &apos;%s.%s-%s.%s&apos; %(x,y[0],x,y[-1])

统计日志IP
    # 打印出独立IP，并统计独立IP数
    219.140.190.130 - - [23/May/2006:08:57:59 +0800] &quot;GET /fg172.exe HTTP/1.1&quot; 200 2350253
    221.228.143.52 - - [23/May/2006:08:58:08 +0800] &quot;GET /fg172.exe HTTP/1.1&quot; 206 719996
    221.228.143.52 - - [23/May/2006:08:58:08 +0800] &quot;GET /fg172.exe HTTP/1.1&quot; 206 713242

    #!/usr/bin/python
    dic={}
    a=open(&quot;a&quot;).readlines()
    for i in a:
        ip=i.strip().split()[0]
        if ip in dic.keys():
            dic[ip] = dic[ip] + 1
        else:
            dic[ip] = 1
    for x,y in dic.items():
        print x,&quot; &quot;,y

多线程下载http

    # 先从文件头中或取content-length的值,即文件大小,在用header中指定Range范围来下载文件中一段字符串
    # &apos;Range&apos;:&apos;bytes=0-499&apos;           # 表示头500个字节
    # &apos;Range&apos;:&apos;bytes=-500&apos;            # 表示最后500个字节
    # &apos;Range&apos;:&apos;bytes=500-&apos;            # 表示500字节以后的范围
    # &apos;Range&apos;:&apos;bytes=0-0,-1&apos;          # 第一个和最后一个字节
    # &apos;Range&apos;:&apos;bytes=50-60,61-99&apos;     # 同时指定几个范围

    #!/usr/bin/env python
    #encoding:utf8
    import urllib2
    import threading


    class myThread(threading.Thread):

        def __init__(self, url_file, scope, url):
            threading.Thread.__init__(self)
            self.url_file = url_file
            self.scope = scope
            self.url = url

        def run(self):

            req_header = {&apos;User-Agent&apos;:&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)&quot;,
            &apos;Accept&apos;:&apos;text/html;q=0.9,*/*;q=0.8&apos;,
            &apos;Range&apos;:&apos;bytes=%s&apos; % self.scope,
            &apos;Accept-Charset&apos;:&apos;ISO-8859-1,utf-8;q=0.7,*;q=0.3&apos;,
            &apos;Connection&apos;:&apos;close&apos;,
            }

            req = urllib2.Request(self.url, headers=req_header)
            data = urllib2.urlopen(req, data=None).read()
            start_value = int(self.scope.split(&apos;-&apos;)[0])

            threadLock.acquire()

            self.url_file.seek(start_value)
            self.url_file.write(data)
            self.url_file.flush()
            threadLock.release()

    if __name__ == &apos;__main__&apos;:

        url = &apos;http://dldir1.qq.com/qqfile/qq/QQ7.1/14522/QQ7.1.exe&apos;
        size=int(urllib2.urlopen(url).info()[&apos;content-length&apos;])
        print size
        threadnum = 4
        len = size / threadnum
        current = 0

        url_file = file(url.split(&apos;/&apos;)[-1],&apos;wb+&apos;)
        threadLock = threading.Lock()
        threads = []
        for tName in range(1, threadnum + 1):

            if tName &lt; threadnum:
                scope = &quot;%d-%d&quot; %(current,len * tName - 1)
                current = len * tName
            elif tName == threadnum:
                    scope = &quot;%d-&quot; %(current)
            print scope
            thread = myThread(url_file, scope, url)
            thread.start()
            threads.append(thread)

        for t in threads:
            t.join()

        url_file.flush()
        url_file.close()

获取网卡流量

    #!/usr/bin/env python

    net = []
    f = open(&quot;/proc/net/dev&quot;)
    lines = f.readlines()
    f.close()
    for line in lines[3:]:
        con = line.split()
        intf = dict(
            zip(
                ( &apos;interface&apos;, &apos;ReceiveBytes&apos;, &apos;ReceivePackets&apos;, &apos;TransmitBytes&apos;, &apos;TransmitPackets&apos;,),
                ( con[0].split(&quot;:&quot;)[0], con[0].split(&quot;:&quot;)[1], int(con[1]), int(con[8]), int(con[9]),)
            )
        )
        net.append(intf)
    print net


阿里云sdk接口

    # 阿里云接口列表
    https://develop.aliyun.com/tools/sdk?#/python

    # python sdk模块
    https://help.aliyun.com/document_detail/30003.html?spm=5176.doc29995.2.1.htCtSa

    # 接口参数详解
    https://help.aliyun.com/document_detail/25500.html?spm=5176.doc25499.6.691.lWwhc0

    pip install aliyun-python-sdk-core aliyun-python-sdk-ecs

    dir(aliyunsdkecs.request)
    v20140526
    aliyunsdkecs.request.v20140526

    #!/usr/bin/env python
    from aliyunsdkcore import client
    from aliyunsdkecs.request.v20140526 import DescribeRegionsRequest

    clt = client.AcsClient(&apos;SFAW************&apos;,&apos;Nc2nZ6dQoiqck0*************&apos;,
    &apos;cn-hangzhou&apos;)

    request=DescribeRegionsRequest.DescribeRegionsRequest()

    print dir(request)

    request.set_accept_format(&apos;json&apos;)
    request.set_action_name(&quot;CreateInstance&quot;)

    print(clt.do_action(request))


获取系统监控信息

    #!/usr/bin/env python
    import inspect
    import os,time,socket

    class mon:
        def __init__(self):
            self.data = {}
        def getLoadAvg(self):
            with open(&apos;/proc/loadavg&apos;) as load_open:
                a = load_open.read().split()[:3]
                #return &quot;%s %s %s&quot; % (a[0],a[1],a[2])
                return   float(a[0])
        def getMemTotal(self):
            with open(&apos;/proc/meminfo&apos;) as mem_open:
                a = int(mem_open.readline().split()[1])
                return a / 1024
        def getMemUsage(self, noBufferCache=True):
            if noBufferCache:
                with open(&apos;/proc/meminfo&apos;) as mem_open:
                    T = int(mem_open.readline().split()[1]) #Total
                    F = int(mem_open.readline().split()[1]) #Free
                    B = int(mem_open.readline().split()[1]) #Buffer
                    C = int(mem_open.readline().split()[1]) #Cache
                    return (T-F-B-C)/1024
            else:
                with open(&apos;/proc/meminfo&apos;) as mem_open:
                    a = int(mem_open.readline().split()[1]) - int(mem_open.readline().split()[1])
                    return a / 1024
        def getMemFree(self, noBufferCache=True):
            if noBufferCache:
                with open(&apos;/proc/meminfo&apos;) as mem_open:
                    T = int(mem_open.readline().split()[1])
                    F = int(mem_open.readline().split()[1])
                    B = int(mem_open.readline().split()[1])
                    C = int(mem_open.readline().split()[1])
                    return (F+B+C)/1024
            else:
                with open(&apos;/proc/meminfo&apos;) as mem_open:
                    mem_open.readline()
                    a = int(mem_open.readline().split()[1])
                    return a / 1024
        def getDiskTotal(self):
            disk = os.statvfs(&quot;/&quot;)
            Total = disk.f_bsize * disk.f_blocks / 1024 / 1024
            return Total
        def getDiskFree(self):
            disk = os.statvfs(&quot;/&quot;)
            Free = disk.f_bsize * disk.f_bavail / 1024 / 1024
            return Free
        def getTraffic(self):
            traffic = {}
            f = open(&quot;/proc/net/dev&quot;)
            lines = f.readlines()
            f.close()
            for line in lines[3:]:
                con = line.split()
                intf = dict(
                    zip(
                        (&apos;ReceiveBytes&apos;, &apos;TransmitBytes&apos;,),
                        (con[0].split(&quot;:&quot;)[1], int(con[8]),)
                    )
                )
                traffic[con[0].split(&quot;:&quot;)[0]] = intf
            return traffic
        def getHost(self):
            #return [&apos;host1&apos;, &apos;host2&apos;, &apos;host3&apos;, &apos;host4&apos;, &apos;host5&apos;][int(time.time() * 1000.0) % 5]
            return socket.gethostname()
        def getTime(self):
            return int(time.time())
        def runAllGet(self):
            for fun in inspect.getmembers(self, predicate=inspect.ismethod):
                if fun[0][:3] == &apos;get&apos;:
                    self.data[fun[0][3:]] = fun[1]()
            return self.data

    if __name__ == &quot;__main__&quot;:
        print mon().runAllGet()


nginx_5xx钉钉报警
    import os
    import sys
    import datetime
    import time
    import requests
    import json

    mtime = (datetime.datetime.now()-datetime.timedelta(minutes=1)).strftime(&quot;%Y-%m-%dT%H:%M&quot;)

    num = int(os.popen(&apos;&apos;&apos;tail -n 100000 /app/nginx/logs/*_access.log | grep %s |grep &apos;status&quot;: 5&apos;  |wc -l  &apos;&apos;&apos; % mtime ).read().strip())
    print num

    if num &gt; 20:
        print &apos;baojing&apos;
        Robot = &apos;https://oapi.dingtalk.com/robot/send?access_token=e80aa431d237d97217827524&apos;
        headers = {&apos;content-type&apos;: &apos;application/json&apos;}
        content = &quot;lite nginx dmz01 5XX: %s&quot; % num

        dingdata = {
            &quot;msgtype&quot;: &quot;text&quot;,
            &quot;text&quot;: {
                &quot;content&quot;: content
            }
        }

        try:
            r = requests.post(url=Robot, data=json.dumps(dingdata), headers=headers, timeout=2).json()
        except Exception as err:
            print &apos;ERROR: notice dingding api error&apos;
            print str(err)


获取主机名

    #!/usr/bin/env python
    # -*- coding: utf8 -*-
    #python network.py --host

    import os
    import socket

    &quot;&quot;&quot;
    copy from:
    http://stackoverflow.com/questions/11735821/python-get-localhost-ip
    &quot;&quot;&quot;

    if os.name != &quot;nt&quot;:
        import fcntl
        import struct

        def get_interface_ip(ifname):
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            return socket.inet_ntoa(fcntl.ioctl(s.fileno(), 0x8915, struct.pack(&apos;256s&apos;, ifname[:15]))[20:24])

    def lan_ip():
        ip = socket.gethostbyname(socket.gethostname())
        if ip.startswith(&quot;127.&quot;) and os.name != &quot;nt&quot;:
            interfaces = [
                &quot;eth0&quot;,
                &quot;eth1&quot;,
                &quot;eth2&quot;,
                &quot;wlan0&quot;,
                &quot;wlan1&quot;,
                &quot;wifi0&quot;,
                &quot;ath0&quot;,
                &quot;ath1&quot;,
                &quot;ppp0&quot;,
            ]
            for ifname in interfaces:
                try:
                    ip = get_interface_ip(ifname)
                    break
                except IOError:
                    pass
        return ip

    if __name__ == &apos;__main__&apos;:
        import sys
        if len(sys.argv) &gt; 1:
            print socket.gethostname()
            sys.exit(0)
        print lan_ip()

LazyManage并发批量操作(判断非root交互到root操作)

    #!/usr/bin/python
    #encoding:utf8
    # LzayManage.py
    # config file: serverlist.conf

    import paramiko
    import multiprocessing
    import sys,os,time,socket,re

    def Ssh_Cmd(host_ip,Cmd,user_name,user_pwd,port=22):
        s = paramiko.SSHClient()
        s.load_system_host_keys()
        s.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        s.connect(hostname=host_ip,port=port,username=user_name,password=user_pwd)
        stdin,stdout,stderr = s.exec_command(Cmd)
        Result = &apos;%s%s&apos; %(stdout.read(),stderr.read())
        q.put(&apos;successful&apos;)
        s.close()
        return Result.strip()

    def Ssh_Su_Cmd(host_ip,Cmd,user_name,user_pwd,root_name,root_pwd,port=22):
        s = paramiko.SSHClient()
        s.load_system_host_keys()
        s.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        s.connect(hostname=host_ip,port=port,username=user_name,password=user_pwd)
        ssh = s.invoke_shell()
        time.sleep(0.1)
        ssh.send(&apos;su - %s\n&apos; %(root_name))
        buff = &apos;&apos;
        while not buff.endswith(&apos;Password: &apos;):
            resp = ssh.recv(9999)
            buff +=resp
        ssh.send(&apos;%s\n&apos; %(root_pwd))
        buff = &apos;&apos;
        while True:
            resp = ssh.recv(9999)
            buff +=resp
            if &apos;: incorrect password&apos; in buff:
                su_correct=&apos;passwd_error&apos;
                break
            elif buff.endswith(&apos;# &apos;):
                su_correct=&apos;passwd_correct&apos;
                break
        if su_correct == &apos;passwd_correct&apos;:
            ssh.send(&apos;%s\n&apos; %(Cmd))
            buff = &apos;&apos;
            while True:
                resp = ssh.recv(9999)
                if resp.endswith(&apos;# &apos;):
                    buff +=re.sub(&apos;\[.*@.*\]# $&apos;,&apos;&apos;,resp)
                    break
                buff +=resp
            Result = buff.lstrip(&apos;%s&apos; %(Cmd))
            q.put(&apos;successful&apos;)
        elif su_correct == &apos;passwd_error&apos;:
            Result = &quot;\033[31mroot密码错误\033[m&quot;
        s.close()
        return Result.strip()

    def Send_File(host_ip,PathList,user_name,user_pwd,Remote=&apos;/tmp&apos;,port=22):
        s=paramiko.Transport((host_ip,port))
        s.connect(username=user_name,password=user_pwd)
        sftp=paramiko.SFTPClient.from_transport(s)
        for InputPath in PathList:
            LocalPath = re.sub(&apos;^\./&apos;,&apos;&apos;,InputPath.rstrip(&apos;/&apos;))
            RemotePath = &apos;%s/%s&apos; %( Remote , os.path.basename( LocalPath ))
            try:
                sftp.rmdir(RemotePath)
            except:
                pass
            try:
                sftp.remove(RemotePath)
            except:
                pass
            if os.path.isdir(LocalPath):
                sftp.mkdir(RemotePath)
                for path,dirs,files in os.walk(LocalPath):
                    for dir in dirs:
                        dir_path = os.path.join(path,dir)
                        sftp.mkdir(&apos;%s/%s&apos; %(RemotePath,re.sub(&apos;^%s/&apos; %LocalPath,&apos;&apos;,dir_path)))
                    for file in files:
                        file_path = os.path.join(path,file)
                        sftp.put( file_path,&apos;%s/%s&apos; %(RemotePath,re.sub(&apos;^%s/&apos; %LocalPath,&apos;&apos;,file_path)))
            else:
                sftp.put(LocalPath,RemotePath)
        q.put(&apos;successful&apos;)
        sftp.close()
        s.close()
        Result = &apos;%s  \033[32m传送完成\033[m&apos; % PathList
        return Result

    def Ssh(host_ip,Operation,user_name,user_pwd,root_name,root_pwd,Cmd=None,PathList=None,port=22):
        msg = &quot;\033[32m-----------Result:%s----------\033[m&quot; % host_ip
        try:
            if Operation == &apos;Ssh_Cmd&apos;:
                Result = Ssh_Cmd(host_ip=host_ip,Cmd=Cmd,user_name=user_name,user_pwd=user_pwd,port=port)
            elif Operation == &apos;Ssh_Su_Cmd&apos;:
                Result = Ssh_Su_Cmd(host_ip=host_ip,Cmd=Cmd,user_name=user_name,user_pwd=user_pwd,root_name=root_name,root_pwd=root_pwd,port=port)
            elif Operation == &apos;Ssh_Script&apos;:
                Send_File(host_ip=host_ip,PathList=PathList,user_name=user_name,user_pwd=user_pwd,port=port)
                Script_Head = open(PathList[0]).readline().strip()
                LocalPath = re.sub(&apos;^\./&apos;,&apos;&apos;,PathList[0].rstrip(&apos;/&apos;))
                Cmd = &apos;%s /tmp/%s&apos; %( re.sub(&apos;^#!&apos;,&apos;&apos;,Script_Head), os.path.basename( LocalPath ))
                Result = Ssh_Cmd(host_ip=host_ip,Cmd=Cmd,user_name=user_name,user_pwd=user_pwd,port=port)
            elif Operation == &apos;Ssh_Su_Script&apos;:
                Send_File(host_ip=host_ip,PathList=PathList,user_name=user_name,user_pwd=user_pwd,port=port)
                Script_Head = open(PathList[0]).readline().strip()
                LocalPath = re.sub(&apos;^\./&apos;,&apos;&apos;,PathList[0].rstrip(&apos;/&apos;))
                Cmd = &apos;%s /tmp/%s&apos; %( re.sub(&apos;^#!&apos;,&apos;&apos;,Script_Head), os.path.basename( LocalPath ))
                Result = Ssh_Su_Cmd(host_ip=host_ip,Cmd=Cmd,user_name=user_name,user_pwd=user_pwd,root_name=root_name,root_pwd=root_pwd,port=port)
            elif Operation == &apos;Send_File&apos;:
                Result = Send_File(host_ip=host_ip,PathList=PathList,user_name=user_name,user_pwd=user_pwd,port=port)
            else:
                Result = &apos;操作不存在&apos;

        except socket.error:
            Result = &apos;\033[31m主机或端口错误\033[m&apos;
        except paramiko.AuthenticationException:
            Result = &apos;\033[31m用户名或密码错误\033[m&apos;
        except paramiko.BadHostKeyException:
            Result = &apos;\033[31mBad host key\033[m[&apos;
        except IOError:
            Result = &apos;\033[31m远程主机已存在非空目录或没有写权限\033[m&apos;
        except:
            Result = &apos;\033[31m未知错误\033[m&apos;
        r.put(&apos;%s\n%s\n&apos; %(msg,Result))

    def Concurrent(Conf,Operation,user_name,user_pwd,root_name,root_pwd,Cmd=None,PathList=None,port=22):
        # 读取配置文件
        f=open(Conf)
        list = f.readlines()
        f.close()
        # 执行总计
        total = 0
        # 并发执行
        for host_info in list:
            # 判断配置文件中注释行跳过
            if host_info.startswith(&apos;#&apos;):
                continue
            # 取变量,其中任意变量未取到就跳过执行
            try:
                host_ip=host_info.split()[0]
                #user_name=host_info.split()[1]
                #user_pwd=host_info.split()[2]
            except:
                print(&apos;Profile error: %s&apos; %(host_info) )
                continue
            try:
                port=int(host_info.split()[3])
            except:
                port=22
            total +=1
            p = multiprocessing.Process(target=Ssh,args=(host_ip,Operation,user_name,user_pwd,root_name,root_pwd,Cmd,PathList,port))
            p.start()
        # 打印执行结果
        for j in range(total):
            print(r.get() )
        if Operation == &apos;Ssh_Script&apos; or Operation == &apos;Ssh_Su_Script&apos;:
            successful = q.qsize() / 2
        else:
            successful = q.qsize()
        print(&apos;\033[32m执行完毕[总执行:%s 成功:%s 失败:%s]\033[m&apos; %(total,successful,total - successful) )
        q.close()
        r.close()

    def Help():
        print(&apos;&apos;&apos;    1.执行命令
        2.执行脚本      \033[32m[位置1脚本(必须带脚本头),后可带执行脚本所需要的包\文件\文件夹路径,空格分隔]\033[m
        3.发送文件      \033[32m[传送的包\文件\文件夹路径,空格分隔]\033[m
        退出: 0\exit\quit
        帮助: help\h\?
        注意: 发送文件默认为/tmp下,如已存在同名文件会被强制覆盖,非空目录则中断操作.执行脚本先将本地脚本及包发送远程主机上,发送规则同发送文件
        &apos;&apos;&apos;)

    if __name__==&apos;__main__&apos;:
        # 定义root账号信息
        root_name = &apos;root&apos;
        root_pwd = &apos;peterli&apos;
        user_name=&apos;peterli&apos;
        user_pwd=&apos;&lt;++(3Ie&apos;
        # 配置文件
        Conf=&apos;serverlist.conf&apos;
        if not os.path.isfile(Conf):
            print(&apos;\033[33m配置文件 %s 不存在\033[m&apos; %(Conf) )
            sys.exit()
        Help()
        while True:
            i = raw_input(&quot;\033[35m[请选择操作]: \033[m&quot;).strip()
            q = multiprocessing.Queue()
            r = multiprocessing.Queue()
            if i == &apos;1&apos;:
                if user_name == root_name:
                    Operation = &apos;Ssh_Cmd&apos;
                else:
                    Operation = &apos;Ssh_Su_Cmd&apos;
                Cmd = raw_input(&apos;CMD: &apos;).strip()
                if len(Cmd) == 0:
                    print(&apos;\033[33m命令为空\033[m&apos;)
                    continue
                Concurrent(Conf=Conf,Operation=Operation,user_name=user_name,user_pwd=user_pwd,root_name=root_name,root_pwd=root_pwd,Cmd=Cmd)
            elif i == &apos;2&apos;:
                if user_name == root_name:
                    Operation = &apos;Ssh_Script&apos;
                else:
                    Operation = &apos;Ssh_Su_Script&apos;
                PathList = raw_input(&apos;\033[36m本地脚本路径: \033[m&apos;).strip().split()
                if len(PathList) == 0:
                    print(&apos;\033[33m路径为空\033[m&apos;)
                    continue
                if not os.path.isfile(PathList[0]):
                    print(&apos;\033[33m本地路径 %s 不存在或不是文件\033[m&apos; %(PathList[0]) )
                    continue
                for LocalPath in PathList[1:]:
                    if not os.path.exists(LocalPath):
                        print(&apos;\033[33m本地路径 %s 不存在\033[m&apos; %(LocalPath) )
                        break
                else:
                    Concurrent(Conf=Conf,Operation=Operation,user_name=user_name,user_pwd=user_pwd,root_name=root_name,root_pwd=root_pwd,PathList=PathList)
            elif i == &apos;3&apos;:
                Operation = &apos;Send_File&apos;
                PathList = raw_input(&apos;\033[36m本地路径: \033[m&apos;).strip().split()
                if len(PathList) == 0:
                    print(&apos;\033[33m路径为空\033[m&apos;)
                    continue
                for LocalPath in PathList:
                    if not os.path.exists(LocalPath):
                        print(&apos;\033[33m本地路径 %s 不存在\033[m&apos; %(LocalPath) )
                        break
                else:
                    Concurrent(Conf=Conf,Operation=Operation,user_name=user_name,user_pwd=user_pwd,root_name=root_name,root_pwd=root_pwd,PathList=PathList)
            elif i == &apos;0&apos; or i == &apos;exit&apos; or i == &apos;quit&apos;:
                print(&quot;\033[34m退出LazyManage脚本\033[m&quot;)
                sys.exit()
            elif i == &apos;help&apos; or i == &apos;h&apos; or i == &apos;?&apos;:
                Help()

epoll非阻塞长链接

    server

        #!/usr/bin/python
        #-*- coding:utf-8 -*-

        import socket, select, logging, errno
        import os, sys, json

        def cmdRunner(input):
            import commands
            cmd_ret = commands.getstatusoutput(input)
            return json.dumps({&apos;ret&apos;:cmd_ret[0], &apos;out&apos;:cmd_ret[1]}, separators=(&apos;,&apos;, &apos;:&apos;))

        class _State:
            def __init__(self):
                self.state = &quot;read&quot;
                self.have_read = 0
                self.need_read = 10
                self.have_write = 0
                self.need_write = 0
                self.data = &quot;&quot;

        __all__ = [&apos;nbNet&apos;]

        class nbNet:

            def __init__(self, host, port, logic):
                self.host = host
                self.port = port
                self.logic = logic
                self.sm = {
                    &quot;read&quot;:self.aread,
                    &quot;write&quot;:self.awrite,
                    &quot;process&quot;:self.aprocess,
                    &quot;closing&quot;:self.aclose,
                }

            def run(self):

                try:
                    self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
                except socket.error, msg:
                    print(&quot;create socket failed&quot;)

                try:
                    self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                except socket.error, msg:
                    print(&quot;setsocketopt SO_REUSEADDR failed&quot;)

                try:
                    self.sock.bind((self.host, self.port))
                except socket.error, msg:
                    print(&quot;bind failed&quot;)

                try:
                    self.sock.listen(10)
                except socket.error, msg:
                    print(msg)

                try:
                    self.epoll_fd = select.epoll()
                    # 向 epoll 句柄中注册 新来socket链接，监听可读事件
                    self.epoll_fd.register(self.sock.fileno(), select.EPOLLIN )
                except select.error, msg:
                    print(msg)

                self.STATE = {}

                while True:
                    print self.STATE
                    # epoll 等待事件回调收发数据
                    epoll_list = self.epoll_fd.poll()
                    for fd, events in epoll_list:
                        if select.EPOLLHUP &amp; events:
                            print &apos;EPOLLHUP&apos;
                            self.STATE[fd][2].state = &quot;closing&quot;
                        elif select.EPOLLERR &amp; events:
                            print &apos;EPOLLERR&apos;
                            self.STATE[fd][2].state = &quot;closing&quot;
                        self.state_machine(fd)
            def state_machine(self, fd):
                if fd == self.sock.fileno():
                    print &quot;state_machine fd %s accept&quot; % fd
                    # fd与初始监听的fd一致,新创建一个连接
                    conn, addr = self.sock.accept()
                    # 设置为非阻塞
                    conn.setblocking(0)
                    self.STATE[conn.fileno()] = [conn, addr, _State()]
                    # 将新建立的链接注册在epoll句柄中,监听可读事件,并设置为EPOLLET高速边缘触发,即触发后不会再次触发直到新接收数据
                    self.epoll_fd.register(conn.fileno(), select.EPOLLET | select.EPOLLIN )
                else:
                    # 否则为历史已存在的fd，调用对应的状态方法
                    print &quot;state_machine fd %s %s&quot; % (fd,self.STATE[fd][2].state)
                    stat = self.STATE[fd][2].state
                    self.sm[stat](fd)
            def aread(self, fd):
                try:
                    # 接收当前fd的可读事件中的数据
                    one_read = self.STATE[fd][0].recv(self.STATE[fd][2].need_read)
                    if len(one_read) == 0:
                        # 接收错误改变状态为关闭
                        self.STATE[fd][2].state = &quot;closing&quot;
                        self.state_machine(fd)
                        return
                    # 将历史接收的数据叠加
                    self.STATE[fd][2].data += one_read
                    self.STATE[fd][2].have_read += len(one_read)
                    self.STATE[fd][2].need_read -= len(one_read)
                    # 接收协议的10个字符
                    if self.STATE[fd][2].have_read == 10:
                        # 通过10个字符得知下次应该具体接收多少字节,存入状态字典中
                        self.STATE[fd][2].need_read += int(self.STATE[fd][2].data)
                        self.STATE[fd][2].data = &apos;&apos;
                        # 调用状态机重新处理
                        self.state_machine(fd)
                    elif self.STATE[fd][2].need_read == 0:
                        # 当接全部收完毕,改变状态,去执行具体服务
                        self.STATE[fd][2].state = &apos;process&apos;
                        self.state_machine(fd)
                except socket.error, msg:
                    self.STATE[fd][2].state = &quot;closing&quot;
                    print(msg)
                    self.state_machine(fd)
                    return

            def aprocess(self, fd):
                # 执行具体执行方法 cmdRunner 得到符合传输协议的返回结果
                response = self.logic(self.STATE[fd][2].data)
                self.STATE[fd][2].data = &quot;%010d%s&quot;%(len(response), response)
                self.STATE[fd][2].need_write = len(self.STATE[fd][2].data)
                # 改变为写的状态
                self.STATE[fd][2].state = &apos;write&apos;
                # 改变监听事件为写
                self.epoll_fd.modify(fd, select.EPOLLET | select.EPOLLOUT)
                self.state_machine(fd)

            def awrite(self, fd):
                try:
                    last_have_send = self.STATE[fd][2].have_write
                    # 发送返回给客户端的数据
                    have_send = self.STATE[fd][0].send(self.STATE[fd][2].data[last_have_send:])
                    self.STATE[fd][2].have_write += have_send
                    self.STATE[fd][2].need_write -= have_send
                    if self.STATE[fd][2].need_write == 0 and self.STATE[fd][2].have_write != 0:
                        # 发送完成,重新初始化状态,并将监听写事件改回读事件
                        self.STATE[fd][2] = _State()
                        self.epoll_fd.modify(fd, select.EPOLLET | select.EPOLLIN)
                except socket.error, msg:
                    self.STATE[fd][2].state = &quot;closing&quot;
                    self.state_machine(fd)
                    print(msg)
                    return

            def aclose(self, fd):
                try:
                    print &apos;Error: %s:%d&apos; %(self.STATE[fd][1][0] ,self.STATE[fd][1][1])
                    # 取消fd的事件监听
                    self.epoll_fd.unregister(fd)
                    # 关闭异常链接
                    self.STATE[fd][0].close()
                    # 删除fd的状态信息
                    self.STATE.pop(fd)
                except:
                    print &apos;Close the abnormal&apos;

        if __name__ == &quot;__main__&quot;:
            HOST = &apos;0.0.0.0&apos;
            PORT = 50005
            nb = nbNet(HOST, PORT, cmdRunner)
            nb.run()

    client

        #!/usr/bin/env python

        import socket, sys, os

        HOST = &apos;0.0.0.0&apos;
        PORT = 50005

        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((HOST, PORT))

        cmd = sys.argv[1]
        while True:
            s.sendall(&quot;%010d%s&quot;%(len(cmd), cmd))
            print cmd
            count = s.recv(10)
            if not count:
                print &apos;-----------&apos;
                print count
                sys.exit()
            count = int(count)
            buf = s.recv(count)
            print buf</code></pre><p>不定期更新下载地址：<br><a href="https://github.com/liquanzhou/ops_doc" target="_blank" rel="noopener">https://github.com/liquanzhou/ops_doc</a></p>
<p>请勿删除信息, 植入广告, 抵制不道德行为</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/home/tags/kubernetes/" rel="tag"># kubernetes</a>
          
        </div>
      

      
      
      

      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Even Chan</p>
              <p class="site-description motion-element" itemprop="description">devops-blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/home/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/home/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#设定编码-支持中文"><span class="nav-number">1.</span> <span class="nav-text">设定编码-支持中文</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Even Chan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/home/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/home/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/home/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/home/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/home/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/home/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/home/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/home/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/home/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/home/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/home/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/home/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/home/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
